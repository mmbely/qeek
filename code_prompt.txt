

--- File: ./tailwind.config.js ---

/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: 'class',
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        'gray-750': '#2D3748',
      },
    },
  },
  plugins: [
    require('@tailwindcss/typography'),
  ],
}



--- File: ./postcss.config.js ---

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


--- File: ./public/index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>


--- File: ./src/App.css ---

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


--- File: ./src/index.css ---

@tailwind base;
@tailwind components;
@tailwind utilities;

--- File: ./src/App.test.tsx ---

import React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


--- File: ./src/index.tsx ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <App />
);

reportWebVitals();


--- File: ./src/App.tsx ---

import React, { useEffect } from 'react';
import { BrowserRouter as Router, Route, Routes, Navigate, useLocation } from 'react-router-dom';
import { AuthProvider, useAuth } from './context/AuthContext';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import ChatInterface from './components/Chat/ChatInterface';
import TicketList from './components/Tickets/TicketList';
import { TicketBoard } from './components/Tickets/TicketBoard';
import Layout from './components/Layout';
import { TicketForm } from './components/Tickets';
import { Connect } from './components/Codebase';
import GitHubSettings from './components/Settings/GitHubSettings';
import { FolderOpen } from 'lucide-react';
import CodebaseViewer from './components/Codebase/CodebaseViewer';
import { CodebaseProvider } from './context/CodebaseContext';
import { AccountProvider } from './context/AccountContext';
import SettingsLayout from './components/Settings/SettingsLayout';
import UserManagement from './components/Settings/UserManagement';
import UserProfile from './components/Settings/UserProfile';
import AdminSettings from './components/Settings/AdminSettings';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

function ProtectedRoute({ children }: ProtectedRouteProps): JSX.Element {
  const { user } = useAuth();
  
  if (!user) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
}

// Add this custom hook for managing titles
function usePageTitle() {
  const location = useLocation();
  
  const getPageTitle = () => {
    const path = location.pathname;
    
    if (path.startsWith('/chat')) {
      return 'Chat';
    } else if (path.startsWith('/tickets/board')) {
      return 'Board';
    } else if (path.startsWith('/tickets/backlog')) {
      return 'Backlog';
    } else if (path.startsWith('/tickets/all')) {
      return 'All Tickets';
    } else if (path.startsWith('/tickets/new')) {
      return 'New Ticket';
    } else if (path === '/login') {
      return 'Login';
    } else if (path === '/register') {
      return 'Register';
    } else if (path.startsWith('/codebase/connect')) {
      return 'Connect Repository';
    } else if (path === '/settings/github') {
      return 'GitHub Settings';
    }
    
    return 'Dashboard';
  };

  return getPageTitle();
}

function AppContent() {
  const pageTitle = usePageTitle();
  
  useEffect(() => {
    document.title = `Q: ${pageTitle}`;
  }, [pageTitle]);

  return (
    <Routes>
      <Route path="/login" element={<LoginPage />} />
      <Route path="/register" element={<RegisterPage />} />
      
      <Route
        element={
          <ProtectedRoute>
            <Layout />
          </ProtectedRoute>
        }
      >
        <Route index element={<Navigate to="/tickets/board" replace />} />
        <Route path="/chat" element={<ChatInterface />} />
        <Route path="/chat/dm/:userId" element={<ChatInterface />} />
        <Route path="/tickets" element={<TicketList />} />
        <Route path="/tickets/backlog" element={<TicketBoard mode="backlog" />} />
        <Route path="/tickets/board" element={<TicketBoard mode="development" />} />
        <Route path="/tickets/all" element={<TicketList />} />
        <Route path="/tickets/new" element={<TicketForm />} />
        <Route path="/codebase/connect" element={<Connect />} />
        <Route path="/codebase/files" element={<CodebaseViewer />} />
        <Route path="/codebase/files/:repositoryName" element={<CodebaseViewer />} />
        <Route path="/settings" element={<SettingsLayout />}>
          <Route index element={<UserProfile />} />
          <Route path="profile" element={<UserProfile />} />
          <Route path="github" element={<GitHubSettings />} />
          <Route path="users" element={<UserManagement />} />
          <Route path="admin" element={<AdminSettings />} />
        </Route>
      </Route>
    </Routes>
  );
}

function App() {
  return (
    <AuthProvider>
      <AccountProvider>
        <CodebaseProvider>
          <Router>
            <AppContent />
          </Router>
        </CodebaseProvider>
      </AccountProvider>
    </AuthProvider>
  );
}

export default App;


--- File: ./src/setupTests.ts ---

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


--- File: ./src/react-app-env.d.ts ---

/// <reference types="react-scripts" />


--- File: ./src/reportWebVitals.ts ---

import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


--- File: ./src/hooks/useTickets.ts ---

import { collection, doc, getDocs, updateDoc, query, where, orderBy, limit, addDoc, deleteDoc } from 'firebase/firestore';
import { db } from '../services/firebase';
import { Ticket } from '../types/ticket';
import { useState, useCallback } from 'react';
import { useAccount } from '../context/AccountContext';

export function useTickets() {
  const { currentAccount } = useAccount();
  const [cachedTickets, setCachedTickets] = useState<Ticket[] | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const getNextTicketNumber = async () => {
    const ticketsRef = collection(db, 'tickets');
    const q = query(
      ticketsRef,
      orderBy('ticket_id', 'desc'),
      limit(1)
    );
    
    const snapshot = await getDocs(q);
    let nextNumber = 1;
    
    if (!snapshot.empty) {
      const lastTicket = snapshot.docs[0].data();
      if (lastTicket.ticket_id) {
        const match = lastTicket.ticket_id.match(/Q-(\d+)/);
        if (match) {
          nextNumber = parseInt(match[1]) + 1;
        }
      }
    }
    
    return nextNumber;
  };

  const updateTicket = useCallback(async (
    ticketId: string,
    updates: Partial<Omit<Ticket, 'id' | 'accountId'>>
  ) => {
    if (!currentAccount?.id) {
      console.error('[useTickets] Cannot update ticket: no account selected');
      return;
    }
    
    try {
      const ticketRef = doc(db, 'tickets', ticketId);
      await updateDoc(ticketRef, {
        ...updates,
        updatedAt: Date.now()
      });
    } catch (error) {
      console.error('[useTickets] Error updating ticket:', error);
      throw error;
    }
  }, [currentAccount]);

  const generateMissingTicketIds = async () => {
    try {
      const ticketsRef = collection(db, 'tickets');
      const querySnapshot = await getDocs(ticketsRef);
      let nextNumber = await getNextTicketNumber();
      const updates = [];

      // Update tickets without IDs
      for (const doc of querySnapshot.docs) {
        const data = doc.data();
        if (!data.ticket_id || !data.ticket_id.match(/Q-\d+/)) {
          const ticket_id = `Q-${String(nextNumber++).padStart(4, '0')}`;
          updates.push(updateDoc(doc.ref, { 
            ticket_id,
            updatedAt: Date.now()
          }));
        }
      }

      await Promise.all(updates);
      setCachedTickets(null); // Clear cache to force refresh
      console.log(`Updated ${updates.length} tickets with new IDs`);
      return updates.length;
    } catch (error) {
      console.error('Error generating missing ticket IDs:', error);
      throw error;
    }
  };

  const getTickets = useCallback(async () => {
    if (!currentAccount?.id) {
      console.log('[useTickets] No current account, returning empty array');
      return [];
    }

    try {
      console.log('[useTickets] Fetching tickets for account:', currentAccount.id);
      
      const ticketsRef = collection(db, 'tickets');
      
      // First try with ordering
      try {
        const ticketsQuery = query(
          ticketsRef,
          where('accountId', '==', currentAccount.id),
          orderBy('order')
        );
        const querySnapshot = await getDocs(ticketsQuery);
        const tickets = querySnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as Ticket[];
        console.log('[useTickets] Found tickets with ordering:', tickets.length);
        return tickets;
      } catch (orderError) {
        console.warn('[useTickets] Error fetching ordered tickets, falling back to unordered:', orderError);
        
        // Fallback to just filtering by accountId without ordering
        const fallbackQuery = query(
          ticketsRef,
          where('accountId', '==', currentAccount.id)
        );
        const fallbackSnapshot = await getDocs(fallbackQuery);
        const fallbackTickets = fallbackSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as Ticket[];
        console.log('[useTickets] Found tickets without ordering:', fallbackTickets.length);
        
        // Sort in memory instead
        return fallbackTickets.sort((a, b) => (a.order || 0) - (b.order || 0));
      }
    } catch (error) {
      console.error('[useTickets] Error fetching tickets:', error);
      return [];
    }
  }, [currentAccount]);

  const createTicket = useCallback(async (ticketData: Omit<Ticket, 'id' | 'accountId'>) => {
    if (!currentAccount?.id) {
      console.error('[useTickets] Cannot create ticket: no account selected');
      return null;
    }
    
    try {
      const newTicket = {
        ...ticketData,
        accountId: currentAccount.id,
      };
      
      const docRef = await addDoc(collection(db, 'tickets'), newTicket);
      
      return {
        id: docRef.id,
        ...newTicket
      };
    } catch (error) {
      console.error('[useTickets] Error creating ticket:', error);
      return null;
    }
  }, [currentAccount]);

  const deleteTicket = async (ticketId: string) => {
    if (!currentAccount?.id) {
      throw new Error('No account selected');
    }

    try {
      const ticketRef = doc(db, 'tickets', ticketId);
      await deleteDoc(ticketRef);
      return true;
    } catch (error) {
      console.error('Error deleting ticket:', error);
      throw error;
    }
  };

  return {
    getTickets,
    createTicket,
    updateTicket,
    deleteTicket,
    generateMissingTicketIds,
    isLoading,
    error
  };
}


--- File: ./src/components/Layout.tsx ---

import React, { useState, useEffect } from 'react';
import { Outlet, useNavigate } from 'react-router-dom';
import { Sidebar } from './Navigation/Sidebar';
import { useAuth } from '../context/AuthContext';
import { useAccount } from '../context/AccountContext';
import { CustomUser } from '../types/user';
import { subscribeToUsers } from '../services/chat';

export default function Layout() {
  const { user, logout, isDarkMode, toggleDarkMode } = useAuth();
  const { currentAccount } = useAccount();
  const navigate = useNavigate();
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const [isDirectMessageModalOpen, setIsDirectMessageModalOpen] = useState(false);
  const [isCreateChannelModalOpen, setIsCreateChannelModalOpen] = useState(false);
  const [currentChannel, setCurrentChannel] = useState('general');
  const [channels] = useState(['general', 'random']);
  const [users, setUsers] = useState<{ [key: string]: CustomUser }>({});

  useEffect(() => {
    if (!currentAccount?.id) {
      console.log('No current account, skipping users subscription');
      return;
    }

    const memberIds = Object.keys(currentAccount.members);
    console.log('Fetching users for members:', memberIds);
    
    const unsubscribe = subscribeToUsers(
      currentAccount.id,
      memberIds,
      (fetchedUsers: { [key: string]: CustomUser }) => {
        console.log('Received users:', fetchedUsers);
        const filteredUsers = Object.fromEntries(
          Object.entries(fetchedUsers).filter(([id]) => id !== user?.uid)
        ) as { [key: string]: CustomUser };
        
        console.log('Filtered users:', filteredUsers);
        setUsers(filteredUsers);
      }
    );

    return () => unsubscribe();
  }, [currentAccount, user?.uid]);

  const handleLogout = async () => {
    try {
      await logout();
      navigate('/login');
    } catch (error) {
      console.error('Failed to log out:', error);
    }
  };

  const getDMChannelId = (user1Id: string, user2Id: string) => {
    const sortedIds = [user1Id, user2Id].sort();
    return `dm_${sortedIds[0]}_${sortedIds[1]}`;
  };

  const handleStartDirectMessage = async (userId: string) => {
    console.log('Starting DM with user:', userId);
    if (!userId || !user?.uid) {
      console.error('No userId provided to handleStartDirectMessage');
      return;
    }
    const dmChannelId = getDMChannelId(user.uid, userId);
    setCurrentChannel(dmChannelId);
    navigate(`/chat/dm/${userId}`);
  };

  return (
    <div className={`flex h-screen ${isDarkMode ? 'dark' : ''}`}>
      <Sidebar
        user={user}
        channels={channels}
        users={users}
        currentChannel={currentChannel}
        isDarkMode={isDarkMode}
        isMobileMenuOpen={isMobileMenuOpen}
        setCurrentChannel={setCurrentChannel}
        setIsMobileMenuOpen={setIsMobileMenuOpen}
        setIsDirectMessageModalOpen={setIsDirectMessageModalOpen}
        setIsCreateChannelModalOpen={setIsCreateChannelModalOpen}
        toggleDarkMode={toggleDarkMode}
        handleLogout={handleLogout}
        handleStartDirectMessage={handleStartDirectMessage}
      />
      <main className="flex-1 overflow-hidden bg-white dark:bg-[#262b3d]">
        <Outlet />
      </main>
    </div>
  );
}

--- File: ./src/components/Settings/UserProfile.tsx ---

import React, { useState, useEffect } from 'react';
import { useAuth } from '../../context/AuthContext';
import { doc, updateDoc, getDoc } from 'firebase/firestore';
import { db } from '../../services/firebase';
import { User, Camera, CheckCircle, XCircle, Loader2 } from 'lucide-react';
import { getStorage, ref, uploadBytes, getDownloadURL } from 'firebase/storage';

interface ProfileForm {
  displayName: string;
  email: string;
  bio?: string;
  location?: string;
  company?: string;
}

export default function UserProfile() {
  const { user } = useAuth();
  const [isLoading, setIsLoading] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const [formData, setFormData] = useState<ProfileForm>({
    displayName: user?.displayName || '',
    email: user?.email || '',
    bio: '',
    location: '',
    company: '',
  });

  useEffect(() => {
    const fetchUserProfile = async () => {
      if (!user) return;
      setIsLoading(true);
      try {
        const userDoc = await doc(db, 'users', user.uid);
        const userData = (await getDoc(userDoc)).data();
        if (userData) {
          setFormData(prev => ({
            ...prev,
            ...userData,
          }));
        }
      } catch (err) {
        console.error('Error fetching user profile:', err);
        setError('Failed to load profile');
      } finally {
        setIsLoading(false);
      }
    };

    fetchUserProfile();
  }, [user]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!user) return;

    setIsSaving(true);
    setError(null);
    setSuccess(false);

    try {
      await updateDoc(doc(db, 'users', user.uid), {
        ...formData,
        updatedAt: new Date(),
      });
      setSuccess(true);
    } catch (err) {
      console.error('Error updating profile:', err);
      setError('Failed to update profile');
    } finally {
      setIsSaving(false);
    }
  };

  const handleAvatarChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!user || !e.target.files?.[0]) return;

    const file = e.target.files[0];
    const storage = getStorage();
    const avatarRef = ref(storage, `avatars/${user.uid}`);

    try {
      setIsLoading(true);
      await uploadBytes(avatarRef, file);
      const photoURL = await getDownloadURL(avatarRef);
      
      await updateDoc(doc(db, 'users', user.uid), {
        photoURL,
        updatedAt: new Date(),
      });
      
      setSuccess(true);
    } catch (err) {
      console.error('Error uploading avatar:', err);
      setError('Failed to update avatar');
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <Loader2 className="h-8 w-8 animate-spin text-gray-500" />
      </div>
    );
  }

  return (
    <div className="p-6 bg-gray-50 dark:bg-gray-900 min-h-full">
      <div className="mb-6">
        <h2 className="text-xl font-semibold text-gray-900 dark:text-gray-100">User Profile</h2>
        <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
          Manage your personal information and preferences
        </p>
      </div>

      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
        <div className="p-6">
          {/* Avatar Section */}
          <div className="mb-6 flex items-center gap-4">
            <div className="relative">
              <div className="w-20 h-20 rounded-full bg-gray-200 dark:bg-gray-700 flex items-center justify-center overflow-hidden">
                {user?.photoURL ? (
                  <img 
                    src={user.photoURL} 
                    alt={formData.displayName} 
                    className="w-full h-full object-cover"
                  />
                ) : (
                  <User className="h-8 w-8 text-gray-500 dark:text-gray-400" />
                )}
              </div>
              <label className="absolute bottom-0 right-0 p-1 bg-white dark:bg-gray-700 rounded-full shadow-lg cursor-pointer">
                <Camera className="h-4 w-4 text-gray-500 dark:text-gray-400" />
                <input
                  type="file"
                  accept="image/*"
                  className="hidden"
                  onChange={handleAvatarChange}
                />
              </label>
            </div>
            <div>
              <h3 className="text-lg font-medium text-gray-900 dark:text-gray-100">
                Profile Picture
              </h3>
              <p className="text-sm text-gray-500 dark:text-gray-400">
                Click the camera icon to update your avatar
              </p>
            </div>
          </div>

          {/* Profile Form */}
          <form onSubmit={handleSubmit} className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Display Name
              </label>
              <input
                type="text"
                value={formData.displayName}
                onChange={(e) => setFormData(prev => ({ ...prev, displayName: e.target.value }))}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md 
                         bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
                required
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Email
              </label>
              <input
                type="email"
                value={formData.email}
                disabled
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md 
                         bg-gray-50 dark:bg-gray-600 text-gray-500 dark:text-gray-400 cursor-not-allowed"
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Bio
              </label>
              <textarea
                value={formData.bio}
                onChange={(e) => setFormData(prev => ({ ...prev, bio: e.target.value }))}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md 
                         bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
                rows={3}
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Location
                </label>
                <input
                  type="text"
                  value={formData.location}
                  onChange={(e) => setFormData(prev => ({ ...prev, location: e.target.value }))}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md 
                           bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Company
                </label>
                <input
                  type="text"
                  value={formData.company}
                  onChange={(e) => setFormData(prev => ({ ...prev, company: e.target.value }))}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md 
                           bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
                />
              </div>
            </div>

            {error && (
              <div className="text-red-500 text-sm flex items-center gap-1">
                <XCircle className="h-4 w-4" />
                {error}
              </div>
            )}

            {success && (
              <div className="text-green-500 text-sm flex items-center gap-1">
                <CheckCircle className="h-4 w-4" />
                Profile updated successfully
              </div>
            )}

            <div className="pt-4">
              <button
                type="submit"
                disabled={isSaving}
                className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 
                         disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isSaving ? 'Saving...' : 'Save Changes'}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
}

--- File: ./src/components/Settings/index.ts ---

export { default as SettingsLayout } from './SettingsLayout';
export { default as GitHubSettings } from './GitHubSettings';
export { default as UserManagement } from './UserManagement';


--- File: ./src/components/Settings/SettingsLayout.tsx ---

import React from 'react';
import { Link, useLocation, Outlet } from 'react-router-dom';
import { Users, Github, Settings, User, Shield } from 'lucide-react';
import { useAuth } from '../../context/AuthContext';

export default function SettingsLayout() {
  const { user } = useAuth();
  const location = useLocation();

  const navItems = [
    {
      label: 'Profile',
      path: '/settings/profile',
      icon: User
    },
    {
      label: 'GitHub Integration',
      path: '/settings/github',
      icon: Github
    },
    {
      label: 'User Management',
      path: '/settings/users',
      icon: Users
    },
    // Only show admin section to super admin
    ...(user?.uid === 'RnInDl1twWVwyWWMcEkB1sETtoq1' ? [{
      label: 'Admin',
      path: '/settings/admin',
      icon: Shield
    }] : [])
  ];

  return (
    <div className="flex h-full">
      {/* Settings Sidebar */}
      <div className="w-64 border-r border-gray-200 dark:border-gray-700 bg-white dark:bg-[#1e2132]">
        <div className="p-4 border-b border-gray-200 dark:border-gray-700">
          <h2 className="text-lg font-semibold flex items-center gap-2 text-gray-900 dark:text-gray-100">
            <Settings className="h-5 w-5" />
            Settings
          </h2>
        </div>
        <nav className="p-2">
          {navItems.map((item) => {
            const isActive = location.pathname === item.path;
            const Icon = item.icon;
            
            return (
              <Link
                key={item.path}
                to={item.path}
                className={`
                  flex items-center gap-2 px-3 py-2 rounded-md mb-1
                  ${isActive 
                    ? 'bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-gray-100' 
                    : 'text-gray-600 dark:text-gray-400 hover:bg-gray-50 dark:hover:bg-gray-800/50'
                  }
                `}
              >
                <Icon className="h-5 w-5" />
                {item.label}
              </Link>
            );
          })}
        </nav>
      </div>

      {/* Content Area */}
      <div className="flex-1 overflow-auto">
        <Outlet />
      </div>
    </div>
  );
}

--- File: ./src/components/Settings/UserManagement.tsx ---

import React, { useState, useEffect } from 'react';
import { useAccount } from '../../context/AccountContext';
import { Mail, UserPlus, Trash2, Shield, CheckCircle, XCircle } from 'lucide-react';
import { doc, getDoc, addDoc, collection, serverTimestamp, setDoc, updateDoc, query, getDocs, where } from 'firebase/firestore';
import { db } from '../../config/firebase';
import { sendEmailInvitation } from '../../services/email';

interface UserData {
  displayName: string;
  email: string;
  photoURL?: string;
}

interface InviteData {
  email: string;
  role: 'admin' | 'member';
}

export default function UserManagement() {
  const { currentAccount } = useAccount();
  const [newUserEmail, setNewUserEmail] = useState('');
  const [newUserRole, setNewUserRole] = useState<'admin' | 'member'>('member');
  const [isAdding, setIsAdding] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [userDetails, setUserDetails] = useState<Record<string, UserData>>({});
  const [isLoadingUsers, setIsLoadingUsers] = useState(true);
  const [isDeletingUser, setIsDeletingUser] = useState<string | null>(null);

  // Improved useEffect for loading user details
  useEffect(() => {
    const loadUserDetails = async () => {
      if (!currentAccount) return;
      
      setIsLoadingUsers(true);
      try {
        const userPromises = Object.keys(currentAccount.members).map(async (userId) => {
          try {
            const userDoc = await getDoc(doc(db, 'users', userId));
            if (userDoc.exists()) {
              return { userId, userData: userDoc.data() as UserData };
            }
          } catch (error) {
            console.error(`Failed to load user ${userId}:`, error);
          }
          return null;
        });

        const users = await Promise.all(userPromises);
        const newUserDetails: Record<string, UserData> = {};
        
        users.forEach(user => {
          if (user) {
            newUserDetails[user.userId] = user.userData;
          }
        });

        setUserDetails(newUserDetails);
      } catch (error) {
        console.error('Failed to load user details:', error);
      } finally {
        setIsLoadingUsers(false);
      }
    };

    loadUserDetails();
  }, [currentAccount]);

  const handleAddUser = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!currentAccount) return;

    setIsAdding(true);
    setError(null);
    setSuccessMessage(null);
    
    try {
      // Check if user exists in Firebase
      const usersRef = collection(db, 'users');
      const q = query(usersRef, where('email', '==', newUserEmail.toLowerCase()));
      const querySnapshot = await getDocs(q);
      
      if (querySnapshot.empty) {
        throw new Error('User not found. Please ensure the email is correct.');
      }

      const userDoc = querySnapshot.docs[0];
      const userId = userDoc.id;

      // Check if user is already a member
      if (currentAccount.members[userId]) {
        throw new Error('User is already a member of this account');
      }

      // Add user to account
      const accountRef = doc(db, 'accounts', currentAccount.id);
      await updateDoc(accountRef, {
        [`members.${userId}`]: {
          role: newUserRole,
          joinedAt: Date.now()
        }
      });

      setSuccessMessage(`User ${newUserEmail} added successfully`);
      setNewUserEmail('');

      // Refresh user details
      const updatedUserDoc = await getDoc(doc(db, 'users', userId));
      if (updatedUserDoc.exists()) {
        setUserDetails(prev => ({
          ...prev,
          [userId]: updatedUserDoc.data() as UserData
        }));
      }
    } catch (err) {
      console.error('Failed to add user:', err);
      setError(err instanceof Error ? err.message : 'Failed to add user. Please try again.');
    } finally {
      setIsAdding(false);
    }
  };

  const handleDeleteUser = async (userId: string) => {
    if (!currentAccount || !window.confirm('Are you sure you want to remove this user?')) return;

    setIsDeletingUser(userId);
    setError(null);
    
    try {
      const accountRef = doc(db, 'accounts', currentAccount.id);
      
      // Create new members object without the deleted user
      const updatedMembers = { ...currentAccount.members };
      delete updatedMembers[userId];
      
      await updateDoc(accountRef, {
        members: updatedMembers
      });

      // Update local state
      setUserDetails(prev => {
        const updated = { ...prev };
        delete updated[userId];
        return updated;
      });

      setSuccessMessage('User removed successfully');
    } catch (err) {
      console.error('Failed to remove user:', err);
      setError(err instanceof Error ? err.message : 'Failed to remove user. Please try again.');
    } finally {
      setIsDeletingUser(null);
    }
  };

  // User Avatar Component
  const UserAvatar = ({ userData }: { userData?: UserData }) => {
    const [imageError, setImageError] = useState(false);
    const initials = userData?.displayName 
      ? userData.displayName.split(' ').map(n => n[0]).join('').toUpperCase()
      : '?';

    if (!userData || imageError) {
      return (
        <div className="w-8 h-8 rounded-full flex items-center justify-center
                      bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300">
          <span className="text-sm font-medium">{initials}</span>
        </div>
      );
    }

    return (
      <div className="w-8 h-8 rounded-full flex items-center justify-center overflow-hidden
                    bg-gray-200 dark:bg-gray-700">
        {userData.photoURL ? (
          <img 
            src={userData.photoURL} 
            alt={userData.displayName || ''}
            className="w-full h-full object-cover"
            onError={() => setImageError(true)}
          />
        ) : (
          <span className="text-sm font-medium text-gray-600 dark:text-gray-300">
            {initials}
          </span>
        )}
      </div>
    );
  };

  return (
    <div className="p-6 bg-gray-50 dark:bg-gray-900 min-h-full">
      <div className="mb-6">
        <h2 className="text-xl font-semibold text-gray-900 dark:text-gray-100">User Management</h2>
        <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
          Manage users and invitations for your account
        </p>
      </div>

      {/* Add User Form */}
      <div className="mb-8 bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
        <div className="p-4 border-b border-gray-200 dark:border-gray-700">
          <h3 className="text-lg font-medium text-gray-900 dark:text-gray-100 flex items-center gap-2">
            <UserPlus className="h-5 w-5" />
            Add New User
          </h3>
        </div>

        <form onSubmit={handleAddUser} className="p-4 space-y-4">
          <div className="flex gap-4">
            <div className="flex-1">
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Email Address
              </label>
              <input
                type="email"
                value={newUserEmail}
                onChange={(e) => setNewUserEmail(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md 
                         bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
                placeholder="user@example.com"
                required
              />
            </div>
            <div className="w-48">
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Role
              </label>
              <select
                value={newUserRole}
                onChange={(e) => setNewUserRole(e.target.value as 'admin' | 'member')}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md 
                         bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
              >
                <option value="member">Member</option>
                <option value="admin">Admin</option>
              </select>
            </div>
          </div>

          {error && (
            <div className="text-red-500 text-sm flex items-center gap-1">
              <XCircle className="h-4 w-4" />
              {error}
            </div>
          )}

          {successMessage && (
            <div className="text-green-500 text-sm flex items-center gap-1">
              <CheckCircle className="h-4 w-4" />
              {successMessage}
            </div>
          )}

          <button
            type="submit"
            disabled={isAdding || !newUserEmail}
            className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 
                     disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isAdding ? 'Adding User...' : 'Add User'}
          </button>
        </form>
      </div>

      {/* Updated Current Users List */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
        <div className="p-4 border-b border-gray-200 dark:border-gray-700">
          <h3 className="text-lg font-medium text-gray-900 dark:text-gray-100">Current Users</h3>
        </div>
        <div className="divide-y divide-gray-200 dark:divide-gray-700">
          {currentAccount && Object.entries(currentAccount.members).map(([userId, member]) => {
            const userData = userDetails[userId];

            return (
              <div key={userId} className="px-4 py-3 flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <UserAvatar userData={userData} />
                  <div>
                    <div className="text-sm font-medium text-gray-900 dark:text-gray-100">
                      {isLoadingUsers ? (
                        <span className="animate-pulse bg-gray-200 dark:bg-gray-700 rounded h-4 w-24 inline-block" />
                      ) : (
                        userData?.displayName || 'Unknown User'
                      )}
                    </div>
                    <div className="text-xs text-gray-500 dark:text-gray-400">
                      {isLoadingUsers ? (
                        <span className="animate-pulse bg-gray-200 dark:bg-gray-700 rounded h-3 w-32 inline-block" />
                      ) : (
                        <>
                          {userData?.email || 'No email'}
                          <span className="mx-1">â€¢</span>
                          Joined {new Date(member.joinedAt).toLocaleDateString()}
                        </>
                      )}
                    </div>
                  </div>
                </div>
                <div className="flex items-center gap-3">
                  <span className="text-sm text-gray-500 dark:text-gray-400 flex items-center gap-1">
                    {member.role === 'admin' && <Shield className="h-4 w-4" />}
                    {member.role}
                  </span>
                  <button 
                    className="text-red-500 hover:text-red-600 p-1 hover:bg-red-50 dark:hover:bg-red-900/20 rounded"
                    title="Remove user"
                    onClick={() => handleDeleteUser(userId)}
                    disabled={isDeletingUser === userId}
                  >
                    <Trash2 className="h-4 w-4" />
                  </button>
                </div>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}

--- File: ./src/components/Settings/AdminSettings.tsx ---

import React, { useState } from 'react';
import { Shield, AlertTriangle, RefreshCw } from 'lucide-react';
import { migrations } from '../../migrations';
import { useAuth } from '../../context/AuthContext';

const SUPER_ADMIN_ID = 'RnInDl1twWVwyWWMcEkB1sETtoq1';

export default function AdminSettings() {
  const { user } = useAuth();
  const [isLoading, setIsLoading] = useState<Record<string, boolean>>({});
  const [results, setResults] = useState<Record<string, { success: boolean; message: string }>>({});

  // If not super admin, don't render anything
  if (user?.uid !== SUPER_ADMIN_ID) {
    return null;
  }

  const handleMigration = async (migrationKey: string) => {
    setIsLoading(prev => ({ ...prev, [migrationKey]: true }));
    try {
      const result = await migrations.tickets.addAccountId();
      setResults(prev => ({
        ...prev,
        [migrationKey]: {
          success: result.success,
          message: result.message || result.error || 'Unknown error'
        }
      }));
    } catch (error) {
      setResults(prev => ({
        ...prev,
        [migrationKey]: {
          success: false,
          message: error instanceof Error ? error.message : 'Unknown error'
        }
      }));
    } finally {
      setIsLoading(prev => ({ ...prev, [migrationKey]: false }));
    }
  };

  return (
    <div className="p-6 bg-gray-50 dark:bg-gray-900 min-h-full">
      <div className="mb-6">
        <div className="flex items-center gap-2">
          <Shield className="h-6 w-6 text-red-500" />
          <h2 className="text-xl font-semibold text-gray-900 dark:text-gray-100">
            Admin Settings
          </h2>
        </div>
        <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
          Super admin actions - handle with care
        </p>
      </div>

      {/* Migrations Section */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
        <div className="p-4 border-b border-gray-200 dark:border-gray-700">
          <h3 className="text-lg font-medium text-gray-900 dark:text-gray-100 flex items-center gap-2">
            <RefreshCw className="h-5 w-5" />
            Database Migrations
          </h3>
        </div>
        <div className="p-4 space-y-4">
          {/* Ticket Account Migration */}
          <div className="border border-yellow-200 dark:border-yellow-900 bg-yellow-50 dark:bg-yellow-900/20 rounded-lg p-4">
            <div className="flex items-start gap-3">
              <AlertTriangle className="h-5 w-5 text-yellow-500 mt-0.5" />
              <div className="flex-1">
                <h4 className="text-sm font-medium text-gray-900 dark:text-gray-100">
                  Migrate Tickets to Account
                </h4>
                <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                  Assigns all unassigned tickets to the default account. This operation cannot be undone.
                </p>
                
                {results['tickets'] && (
                  <div className={`mt-2 text-sm ${
                    results['tickets'].success ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
                  }`}>
                    {results['tickets'].message}
                  </div>
                )}

                <div className="mt-3">
                  <button
                    onClick={() => handleMigration('tickets')}
                    disabled={isLoading['tickets']}
                    className="px-3 py-1.5 bg-yellow-500 text-white text-sm rounded-md hover:bg-yellow-600 
                             disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                  >
                    {isLoading['tickets'] ? (
                      <>
                        <RefreshCw className="h-4 w-4 animate-spin" />
                        Running Migration...
                      </>
                    ) : (
                      'Run Migration'
                    )}
                  </button>
                </div>
              </div>
            </div>
          </div>

          {/* Add more admin actions here */}
        </div>
      </div>

      {/* System Status Section - Optional */}
      <div className="mt-6 bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
        <div className="p-4 border-b border-gray-200 dark:border-gray-700">
          <h3 className="text-lg font-medium text-gray-900 dark:text-gray-100">System Status</h3>
        </div>
        <div className="p-4">
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Add system status information here
          </p>
        </div>
      </div>
    </div>
  );
}

--- File: ./src/components/Settings/GitHubSettings.tsx ---

import React, { useState, useEffect, useMemo } from 'react';
import { Github, CheckCircle, XCircle, Loader2, ChevronDown, Search } from "lucide-react";
import { githubService } from '../../services/github';
import { useAuth } from '../../context/AuthContext';
import { useCodebase } from '../../context/CodebaseContext';
import type { GitHubRepo } from '../../services/github';
import { useAccount } from '../../context/AccountContext';

export default function GitHubSettings() {
  const { user } = useAuth();
  const { selectedRepository, setSelectedRepository } = useCodebase();
  const [token, setToken] = useState('');
  const [isConnected, setIsConnected] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showToken, setShowToken] = useState(false);
  const [repositories, setRepositories] = useState<GitHubRepo[]>([]);
  const [selectedRepo, setSelectedRepo] = useState<GitHubRepo | null>(null);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const { currentAccount, updateAccountSettings } = useAccount();
  const [showSavedMessage, setShowSavedMessage] = useState(false);

  // Filter repositories based on search query
  const filteredRepositories = useMemo(() => {
    return repositories.filter(repo => 
      repo.full_name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      (repo.description?.toLowerCase() || '').includes(searchQuery.toLowerCase())
    );
  }, [repositories, searchQuery]);

  useEffect(() => {
    const loadGitHubStatus = async () => {
      if (user?.uid) {
        try {
          const savedToken = await githubService.getToken(user.uid);
          if (savedToken) {
            setIsConnected(true);
            // Fetch repositories after confirming connection
            const repos = await githubService.fetchUserRepositories(user.uid);
            setRepositories(repos);
            
            // Get selected repository
            const savedRepo = await githubService.getSelectedRepository(user.uid);
            if (savedRepo) {
              const repo = repos.find(r => r.full_name === savedRepo);
              if (repo) {
                setSelectedRepo(repo);
                setSelectedRepository(repo.full_name);
              }
            }
          }
        } catch (err) {
          console.error('Error loading GitHub status:', err);
        } finally {
          setIsLoading(false);
        }
      }
    };

    loadGitHubStatus();
  }, [user, setSelectedRepository]);

  const handleConnect = async () => {
    if (!user?.uid) return;

    try {
      setIsLoading(true);
      setError(null);

      const isValid = await githubService.validateToken(token);
      
      if (isValid) {
        await githubService.setToken(user.uid, token);
        setIsConnected(true);
        // Fetch repositories after successful connection
        const repos = await githubService.fetchUserRepositories(user.uid);
        setRepositories(repos);
        setToken(''); // Clear input
      } else {
        setError('Invalid GitHub token. Please check and try again.');
      }
    } catch (err) {
      console.error('Failed to connect:', err);
      setError('Failed to connect. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleDisconnect = async () => {
    if (!user?.uid) return;

    try {
      setIsLoading(true);
      await githubService.clearToken(user.uid);
      setIsConnected(false);
      setRepositories([]);
      setSelectedRepository(null);
    } catch (err) {
      console.error('Failed to disconnect:', err);
      setError('Failed to disconnect. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleRepositorySelect = async (repo: GitHubRepo) => {
    if (!user?.uid || !currentAccount) return;

    try {
      setSelectedRepo(repo);
      setSelectedRepository(repo.full_name);
      
      // Update account settings with the selected repository
      await updateAccountSettings({
        githubRepository: repo.full_name
      });
      
      // Show success message
      setShowSavedMessage(true);
      setTimeout(() => setShowSavedMessage(false), 2000); // Hide after 2 seconds
      
      setIsDropdownOpen(false);
      setSearchQuery('');
    } catch (err) {
      console.error('Failed to select repository:', err);
      setError('Failed to select repository. Please try again.');
    }
  };

  if (isLoading) {
    return (
      <div className="animate-pulse p-6">
        <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/4 mb-4"></div>
        <div className="h-8 bg-gray-200 dark:bg-gray-700 rounded w-1/2"></div>
      </div>
    );
  }

  return (
    <div className="bg-white dark:bg-[#1e2132] rounded-lg shadow p-6">
      <div className="flex items-center justify-between mb-6">
        <div>
          <h2 className="text-xl font-semibold text-gray-900 dark:text-gray-200">
            GitHub Integration
          </h2>
          <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
            Connect your GitHub account to enable repository access
          </p>
        </div>
        <Github className="h-8 w-8 text-gray-400" />
      </div>

      {error && (
        <div className="mb-4 p-4 text-red-500 bg-red-100 dark:bg-red-900/20 rounded-lg flex items-center gap-2">
          <XCircle className="h-5 w-5" />
          {error}
        </div>
      )}

      {isConnected ? (
        <div className="space-y-4">
          <div className="flex items-center gap-2 text-green-500 dark:text-green-400">
            <CheckCircle className="h-5 w-5" />
            <span>Connected to GitHub</span>
          </div>
          <button
            onClick={handleDisconnect}
            className="text-red-500 hover:text-red-600 text-sm font-medium"
          >
            Disconnect
          </button>
        </div>
      ) : (
        <div className="space-y-4">
          <div className="text-sm text-gray-600 dark:text-gray-400">
            <p>To connect your GitHub repository:</p>
            <ol className="list-decimal list-inside space-y-2 mt-2">
              <li>Go to GitHub Settings â†’ Developer Settings â†’ Personal Access Tokens â†’ Tokens (classic)</li>
              <li>Generate a new token with 'repo' scope</li>
              <li>Copy the token and paste it below</li>
            </ol>
          </div>

          <div className="space-y-2">
            <label htmlFor="token" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
              GitHub Personal Access Token
            </label>
            <div className="relative">
              <input
                type={showToken ? "text" : "password"}
                id="token"
                value={token}
                onChange={(e) => setToken(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md 
                         dark:bg-gray-700 dark:text-gray-100"
                placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
              />
              <button
                type="button"
                onClick={() => setShowToken(!showToken)}
                className="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-500 text-sm"
              >
                {showToken ? 'Hide' : 'Show'}
              </button>
            </div>
          </div>

          <button
            onClick={handleConnect}
            disabled={isLoading || !token}
            className={`
              w-full flex items-center justify-center gap-2 px-4 py-2
              bg-[#2b2f44] hover:bg-[#363b52] disabled:opacity-50
              text-gray-200
              rounded-lg transition-colors duration-200
            `}
          >
            <Github className="h-5 w-5" />
            {isLoading ? 'Connecting...' : 'Connect GitHub Repository'}
          </button>
        </div>
      )}

      {/* Repository Selection UI */}
      {isConnected && repositories.length > 0 && (
        <div className="mt-6 border-t border-gray-200 dark:border-gray-700 pt-6">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-medium text-gray-900 dark:text-gray-200">
              Select Repository
            </h3>
            {showSavedMessage && (
              <div className="flex items-center text-green-500 text-sm">
                <CheckCircle className="h-4 w-4 mr-1" />
                Repository saved
              </div>
            )}
          </div>
          <div className="relative">
            <button
              onClick={() => setIsDropdownOpen(!isDropdownOpen)}
              className="w-full flex items-center justify-between px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
            >
              <span>{selectedRepo ? selectedRepo.full_name : 'Choose a repository'}</span>
              <ChevronDown className="h-5 w-5" />
            </button>

            {isDropdownOpen && (
              <div className="absolute z-10 w-full mt-1 bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg">
                {/* Search input */}
                <div className="p-2 border-b border-gray-200 dark:border-gray-600">
                  <div className="relative">
                    <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <input
                      type="text"
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      placeholder="Search repositories..."
                      className="w-full pl-9 pr-4 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md 
                               bg-gray-50 dark:bg-gray-800 
                               text-gray-900 dark:text-gray-100
                               placeholder-gray-500 dark:placeholder-gray-400
                               focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400"
                    />
                  </div>
                </div>

                {/* Repository list */}
                <div className="max-h-60 overflow-auto">
                  {filteredRepositories.length === 0 ? (
                    <div className="px-4 py-3 text-sm text-gray-500 dark:text-gray-400 text-center">
                      No repositories found
                    </div>
                  ) : (
                    filteredRepositories.map((repo) => (
                      <button
                        key={repo.id}
                        onClick={() => handleRepositorySelect(repo)}
                        className="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-600 text-gray-900 dark:text-gray-100"
                      >
                        <div className="font-medium">{repo.full_name}</div>
                        {repo.description && (
                          <div className="text-sm text-gray-500 dark:text-gray-400 truncate">
                            {repo.description}
                          </div>
                        )}
                      </button>
                    ))
                  )}
                </div>

                {/* Show count when filtering */}
                {searchQuery && (
                  <div className="px-4 py-2 text-xs text-gray-500 dark:text-gray-400 border-t border-gray-200 dark:border-gray-600">
                    Found {filteredRepositories.length} repositories
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}


--- File: ./src/components/Auth/Login.tsx ---

import React, { useState } from 'react';
import { useAuth } from '../../context/AuthContext';
import { useNavigate, Link } from 'react-router-dom';
import { AlertCircle } from "lucide-react";

const Login: React.FC<{ onSuccess: () => void }> = ({ onSuccess }) => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [rememberMe, setRememberMe] = useState(false);
  const [error, setError] = useState('');
  const { login, googleSignIn } = useAuth();
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    if (!email || !password) {
      setError('Please fill in all fields');
      return;
    }
    try {
      await login(email, password);
      onSuccess();
    } catch (err) {
      setError('Failed to log in');
    }
  };

  const handleGoogleSignIn = async () => {
    try {
      await googleSignIn();
      onSuccess();
    } catch (err) {
      setError('Failed to sign in with Google');
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-100 dark:bg-gray-900">
      <div className="w-full max-w-md bg-white dark:bg-gray-800 rounded-lg shadow-md p-6">
        <div className="space-y-1 mb-4">
          <h2 className="text-2xl font-bold">Login</h2>
          <p className="text-sm text-gray-500 dark:text-gray-400">Enter your email and password to login to your account</p>
        </div>
        <form onSubmit={handleSubmit}>
          <div className="space-y-4">
            {error && (
              <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                <AlertCircle className="h-4 w-4 inline mr-2" />
                <span className="block sm:inline">{error}</span>
              </div>
            )}
            <div className="space-y-2">
              <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-200">Email</label>
              <input
                id="email"
                type="email"
                placeholder="m@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
              />
            </div>
            <div className="space-y-2">
              <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-200">Password</label>
              <input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
              />
            </div>
            <div className="flex items-center space-x-2">
              <input
                type="checkbox"
                id="remember"
                checked={rememberMe}
                onChange={(e) => setRememberMe(e.target.checked)}
                className="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
              />
              <label htmlFor="remember" className="text-sm text-gray-700 dark:text-gray-200">Remember me</label>
            </div>
          </div>
          <button type="submit" className="w-full mt-6 px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
            Login
          </button>
        </form>
        <div className="mt-4">
          <button
            onClick={handleGoogleSignIn}
            className="w-full px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
          >
            Sign in with Google
          </button>
        </div>
        <div className="mt-4">
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Don't have an account?{' '}
            <Link to="/register" className="text-indigo-600 hover:underline dark:text-indigo-400">
              Register
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
};

export default Login;


--- File: ./src/components/Auth/Register.tsx ---

import React, { useState } from 'react';
import { useAuth } from '../../context/AuthContext';
import { useNavigate, Link } from 'react-router-dom';
import { AlertCircle } from "lucide-react";

const Register: React.FC = () => {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [passwordError, setPasswordError] = useState('');
  const { register, googleSignIn } = useAuth();
  const navigate = useNavigate();

  const validatePassword = (password: string) => {
    const minLength = 8;
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasNonalphas = /\W/.test(password);
    if (password.length < minLength) {
      return "Password must be at least 8 characters long.";
    } else if (!(hasUpperCase && hasLowerCase && hasNumbers && hasNonalphas)) {
      return "Password must contain an uppercase letter, lowercase letter, number, and special character.";
    }
    return "";
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    if (!name || !email || !password || !confirmPassword) {
      setError('Please fill in all fields');
      return;
    }
    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }
    const passwordValidationError = validatePassword(password);
    if (passwordValidationError) {
      setPasswordError(passwordValidationError);
      return;
    }
    try {
      await register(email, password);
      navigate('/');
    } catch (err) {
      setError('Failed to create an account');
    }
  };

  const handleGoogleSignUp = async () => {
    try {
      await googleSignIn();
      navigate('/');
    } catch (err) {
      setError('Failed to sign up with Google');
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-100 dark:bg-gray-900">
      <div className="w-full max-w-md bg-white dark:bg-gray-800 rounded-lg shadow-md p-6">
        <div className="space-y-1 mb-4">
          <h2 className="text-2xl font-bold">Create an account</h2>
          <p className="text-sm text-gray-500 dark:text-gray-400">Enter your details to create your account</p>
        </div>
        <form onSubmit={handleSubmit}>
          <div className="space-y-4">
            {error && (
              <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                <AlertCircle className="h-4 w-4 inline mr-2" />
                <span className="block sm:inline">{error}</span>
              </div>
            )}
            <div className="space-y-2">
              <label htmlFor="name" className="block text-sm font-medium text-gray-700 dark:text-gray-200">Full Name</label>
              <input
                id="name"
                type="text"
                placeholder="John Doe"
                value={name}
                onChange={(e) => setName(e.target.value)}
                required
                className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
              />
            </div>
            <div className="space-y-2">
              <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-200">Email</label>
              <input
                id="email"
                type="email"
                placeholder="m@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
              />
            </div>
            <div className="space-y-2">
              <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-200">Password</label>
              <input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
              />
            </div>
            <div className="space-y-2">
              <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700 dark:text-gray-200">Confirm Password</label>
              <input
                id="confirmPassword"
                type="password"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                required
                className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
              />
            </div>
          </div>
          <button 
            type="submit" 
            className="w-full mt-6 px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          >
            Register
          </button>
        </form>
        <div className="mt-4">
          <button
            onClick={handleGoogleSignUp}
            className="w-full px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
          >
            Sign up with Google
          </button>
        </div>
        <div className="mt-4">
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Already have an account?{' '}
            <Link to="/login" className="text-indigo-600 hover:underline dark:text-indigo-400">
              Login
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
};

export default Register;


--- File: ./src/components/Tickets/TicketForm.tsx ---

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { collection, addDoc, query, where, getDocs, orderBy, limit } from 'firebase/firestore';
import { db } from '../../services/firebase';
import { useAuth } from '../../context/AuthContext';
import { Ticket } from '../../types/ticket';
import { useAccount } from '../../context/AccountContext';

export default function TicketForm() {
  const navigate = useNavigate();
  const { user } = useAuth();
  const { currentAccount } = useAccount();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!currentAccount) return;

    setLoading(true);
    setError(null);

    try {
      const formData = new FormData(e.currentTarget);
      
      // Get the current highest ticket_id
      const ticketsRef = collection(db, 'tickets');
      const ticketsQuery = query(
        ticketsRef,
        orderBy('ticket_id', 'desc'),
        limit(1)
      );
      
      const ticketsSnapshot = await getDocs(ticketsQuery);
      let nextNumber = 1;
      
      if (!ticketsSnapshot.empty) {
        const lastTicket = ticketsSnapshot.docs[0].data();
        const lastNumber = parseInt(lastTicket.ticket_id.split('-')[1]);
        nextNumber = lastNumber + 1;
      }

      const ticket_id = `Q-${String(nextNumber).padStart(4, '0')}`;

      const ticketData: Omit<Ticket, 'id'> = {
        title: formData.get('title') as string,
        description: formData.get('description') as string,
        status: 'BACKLOG_NEW',
        priority: 'medium',
        type: 'task',
        createdBy: user?.uid || '',
        createdAt: Date.now(),
        updatedAt: Date.now(),
        order: nextNumber,
        ticket_id,
        accountId: currentAccount.id
      };

      await addDoc(collection(db, 'tickets'), ticketData);
      navigate('/tickets');
    } catch (error) {
      setError('Failed to create ticket. Please try again.');
      console.error('Error creating ticket:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6">Create New Ticket</h1>
      
      {error && (
        <div className="mb-4 p-4 bg-red-50 text-red-600 rounded">
          {error}
        </div>
      )}

      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-1">
            Title
          </label>
          <input
            type="text"
            id="title"
            name="title"
            required
            className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            placeholder="Enter ticket title"
          />
        </div>

        <div>
          <label htmlFor="description" className="block text-sm font-medium text-gray-700 mb-1">
            Description
          </label>
          <textarea
            id="description"
            name="description"
            required
            rows={4}
            className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            placeholder="Enter ticket description"
          />
        </div>

        <div>
          <label htmlFor="priority" className="block text-sm font-medium text-gray-700 mb-1">
            Priority
          </label>
          <select
            id="priority"
            name="priority"
            required
            className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          >
            <option value="low">Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
          </select>
        </div>

        <div className="flex justify-end space-x-2 pt-4">
          <button
            type="button"
            onClick={() => navigate('/tickets')}
            className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded transition-colors"
          >
            Cancel
          </button>
          <button
            type="submit"
            disabled={loading}
            className="px-4 py-2 bg-blue-600 text-white rounded shadow-sm hover:bg-blue-700 transition-colors disabled:bg-blue-400"
          >
            {loading ? 'Creating...' : 'Create Ticket'}
          </button>
        </div>
      </form>
    </div>
  );
}


--- File: ./src/components/Tickets/TicketEdit.tsx ---

import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { ticketService } from '../../services/ticketService';
import { Ticket } from '../../types/ticket';
import { db } from '../../services/firebase';

export default function TicketEdit() {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [ticket, setTicket] = useState<Ticket | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadTicket = async () => {
      if (id) {
        const ticketData = await ticketService.getTicket(id);
        setTicket(ticketData);
      }
      setLoading(false);
    };
    loadTicket();
  }, [id]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (ticket && id) {
      await ticketService.updateTicket(id, ticket);
      navigate('/tickets');
    }
  };

  if (loading) {
    return <div className="flex-1 p-4">Loading...</div>;
  }

  if (!ticket) {
    return <div className="flex-1 p-4">Ticket not found</div>;
  }

  return (
    <div className="flex-1 p-4">
      <div className="max-w-2xl mx-auto">
        <div className="mb-6">
          <h1 className="text-2xl font-bold mb-2">Edit Ticket</h1>
          {ticket.ticket_id && (
            <p className="text-gray-600">Ticket ID: {ticket.ticket_id}</p>
          )}
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          {!ticket.ticket_id && (
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Ticket ID
              </label>
              <input
                type="text"
                value={ticket.ticket_id || ''}
                disabled
                className="w-full px-3 py-2 border border-gray-300 rounded-md bg-gray-50"
                placeholder="Will be generated on save"
              />
            </div>
          )}
          <div>
            <label htmlFor="title" className="block text-sm font-medium text-gray-700 dark:text-gray-200">
              Title
            </label>
            <input
              type="text"
              id="title"
              value={ticket.title}
              onChange={(e) => setTicket({ ...ticket, title: e.target.value })}
              required
              className="mt-1 block w-full rounded-md border border-gray-300 dark:border-gray-600 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-white p-2"
            />
          </div>
          <div>
            <label htmlFor="description" className="block text-sm font-medium text-gray-700 dark:text-gray-200">
              Description
            </label>
            <textarea
              id="description"
              value={ticket.description}
              onChange={(e) => setTicket({ ...ticket, description: e.target.value })}
              rows={4}
              className="mt-1 block w-full rounded-md border border-gray-300 dark:border-gray-600 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-white p-2"
            />
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
              <label htmlFor="status" className="block text-sm font-medium text-gray-700 dark:text-gray-200">
                Status
              </label>
              <select
                id="status"
                value={ticket.status}
                onChange={(e) => setTicket({ ...ticket, status: e.target.value as Ticket['status'] })}
                className="mt-1 block w-full rounded-md border border-gray-300 dark:border-gray-600 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-white p-2"
              >
                <option value="BACKLOG">Backlog</option>
                <option value="SELECTED_FOR_DEV">Selected for Dev</option>
                <option value="IN_PROGRESS">In Progress</option>
                <option value="READY_FOR_TESTING">Ready for Testing</option>
                <option value="DEPLOYED">Deployed</option>
              </select>
            </div>
            <div>
              <label htmlFor="priority" className="block text-sm font-medium text-gray-700 dark:text-gray-200">
                Priority
              </label>
              <select
                id="priority"
                value={ticket.priority}
                onChange={(e) => setTicket({ ...ticket, priority: e.target.value as Ticket['priority'] })}
                className="mt-1 block w-full rounded-md border border-gray-300 dark:border-gray-600 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-white p-2"
              >
                <option value="LOW">Low</option>
                <option value="MEDIUM">Medium</option>
                <option value="HIGH">High</option>
              </select>
            </div>
          </div>
          <div className="flex justify-end space-x-2 pt-4">
            <button
              type="button"
              onClick={() => navigate('/tickets')}
              className="px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-700"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700"
            >
              Save Changes
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}

--- File: ./src/components/Tickets/TicketViewSwitch.tsx ---

import React from 'react';
import { List, LayoutGrid } from 'lucide-react';

type ViewSwitchProps = {
  view: 'list' | 'board';
  onViewChange: (view: 'list' | 'board') => void;
};

export default function TicketViewSwitch({ view, onViewChange }: ViewSwitchProps) {
  return (
    <div className="flex items-center space-x-2">
      <button
        onClick={() => onViewChange('list')}
        className={`p-2 rounded-md ${
          view === 'list'
            ? 'bg-indigo-100 text-indigo-700 dark:bg-indigo-900 dark:text-indigo-100'
            : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200'
        }`}
      >
        <List className="h-5 w-5" />
      </button>
      <button
        onClick={() => onViewChange('board')}
        className={`p-2 rounded-md ${
          view === 'board'
            ? 'bg-indigo-100 text-indigo-700 dark:bg-indigo-900 dark:text-indigo-100'
            : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200'
        }`}
      >
        <LayoutGrid className="h-5 w-5" />
      </button>
    </div>
  );
}

--- File: ./src/components/Tickets/index.ts ---

export { default as TicketList } from './TicketList';
export { default as TicketForm } from './TicketForm';
export { default as TicketEdit } from './TicketEdit';
export { default as TicketBoard } from './TicketBoard';

--- File: ./src/components/Tickets/TicketBoard.tsx ---

import React, { useState, useEffect, useCallback } from 'react';
import { doc, updateDoc, writeBatch } from 'firebase/firestore';
import { db } from '../../config/firebase';
import { Ticket } from '../../types/ticket';
import { useAuth } from '../../context/AuthContext';
import { database } from '../../config/firebase';
import { ref, get, onValue } from 'firebase/database';
import { DragDropContext, Droppable, Draggable, DropResult } from '@hello-pangea/dnd';
import TicketModal from './TicketModal';
import { Plus, AlertCircle } from 'lucide-react';
import { theme, commonStyles, typography, layout, animations } from '../../styles';
import { useTickets } from '../../hooks/useTickets';
import { useAccount } from '../../context/AccountContext';
import { 
  COLUMN_STATUS_LABELS,
  Column,
  BacklogColumnsType,
  DevelopmentColumnsType,
  backlogColumns,
  developmentColumns
} from '../../types/board';
import { TicketStatus } from '../../types/board';
import { getAuth } from 'firebase/auth';

type BoardMode = 'development' | 'backlog';

interface TicketBoardProps {
  mode?: BoardMode;
}

// Define ColumnsType as union of both column types
type ColumnsType = BacklogColumnsType | DevelopmentColumnsType;

export function TicketBoard({ mode = 'development' }: TicketBoardProps) {
  const { user } = useAuth();
  const { currentAccount } = useAccount();
  const { getTickets, updateTicket } = useTickets();
  const [tickets, setTickets] = useState<Ticket[]>([]);
  const [users, setUsers] = useState<{[key: string]: any}>({});
  const [columns, setColumns] = useState<ColumnsType>(
    mode === 'development' ? developmentColumns : backlogColumns
  );
  const title = mode === 'development' ? 'Development Board' : 'Backlog Board';
  const subtitle = mode === 'development' 
    ? "Manage your team's tickets"
    : 'Manage your upcoming tickets';
  const [selectedTicket, setSelectedTicket] = useState<Ticket | undefined>();
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  const [failedTicketId, setFailedTicketId] = useState<string | null>(null);
  const [authUsers, setAuthUsers] = useState<{[key: string]: any}>({});

  // Type guards
  const isDevelopmentColumns = (cols: ColumnsType): cols is DevelopmentColumnsType => {
    return 'SELECTED_FOR_DEV' in cols;
  };

  const isBacklogColumns = (cols: ColumnsType): cols is BacklogColumnsType => {
    return 'BACKLOG_DEV_NEXT' in cols;
  };

  // Fetch auth users
  useEffect(() => {
    const auth = getAuth();
    const fetchAuthUsers = async () => {
      console.log('[TicketBoard] Starting auth user fetch');
      // First get realtime database users for online status
      const usersRef = ref(database, 'users');
      const snapshot = await get(usersRef);
      const realtimeUsers = snapshot.exists() ? snapshot.val() : {};
      
      // Then merge with auth user data
      const mergedUsers = { ...realtimeUsers };
      if (auth.currentUser) {
        mergedUsers[auth.currentUser.uid] = {
          ...mergedUsers[auth.currentUser.uid],
          displayName: auth.currentUser.displayName,
          email: auth.currentUser.email,
          photoURL: auth.currentUser.photoURL,
        };
      }
      
      console.log('[TicketBoard] Merged users:', mergedUsers);
      setUsers(mergedUsers);
    };
    
    fetchAuthUsers();
  }, []);

  // Fetch tickets using useTickets hook
  useEffect(() => {
    const fetchTickets = async () => {
      if (!currentAccount?.id) return;
      
      try {
        const ticketsData = await getTickets();
        console.log('[TicketBoard] Fetched tickets:', ticketsData);

        // Sort tickets by order
        const sortedTickets = [...ticketsData].sort((a, b) => (a.order || 0) - (b.order || 0));
        
        // Create fresh columns with proper typing
        const newColumns = mode === 'development' 
          ? { ...developmentColumns } as DevelopmentColumnsType
          : { ...backlogColumns } as BacklogColumnsType;

        // Distribute tickets to columns
        sortedTickets.forEach(ticket => {
          if (isDevelopmentColumns(newColumns)) {
            if (ticket.status in newColumns) {
              newColumns[ticket.status as keyof DevelopmentColumnsType].tickets.push(ticket);
            }
          } else {
            if (ticket.status in newColumns) {
              newColumns[ticket.status as keyof BacklogColumnsType].tickets.push(ticket);
            }
          }
        });

        setTickets(ticketsData);
        setColumns(newColumns);
      } catch (error) {
        console.error('Error fetching tickets:', error);
      }
    };

    fetchTickets();
  }, [currentAccount?.id, getTickets, mode]);

  const getUserName = (userId: string) => {
    if (!userId) return 'Unassigned';
    
    const userInfo = users[userId];
    if (!userInfo) return 'Unknown User';
    
    return userInfo.displayName || userInfo.email || 'Unknown User';
  };

  const handleDragEnd = async (result: DropResult) => {
    const { source, destination, draggableId } = result;
    if (!destination) return;

    const sourceStatus = source.droppableId as TicketStatus;
    const destStatus = destination.droppableId as TicketStatus;

    // Create a new columns object to avoid mutating state
    const newColumns = { ...columns };

    // Use type guards to ensure proper column access
    if (!isDevelopmentColumns(newColumns) && !isBacklogColumns(newColumns)) {
      console.error('Invalid column type');
      return;
    }

    // Type assertion for column access
    type ValidColumnKey = keyof typeof newColumns;
    
    if (!(sourceStatus in newColumns) || !(destStatus in newColumns)) {
      console.error('Invalid status transition');
      return;
    }

    const sourceColumn = newColumns[sourceStatus as ValidColumnKey] as Column;
    const draggedTicket = sourceColumn.tickets.find((t: Ticket) => t.id === draggableId);
    if (!draggedTicket) return;

    // Immediately update UI state (optimistic update)
    if (sourceStatus === destStatus) {
      const columnTickets = [...sourceColumn.tickets];
      columnTickets.splice(source.index, 1);
      columnTickets.splice(destination.index, 0, draggedTicket);
      (newColumns[sourceStatus as ValidColumnKey] as Column).tickets = columnTickets;
    } else {
      const destColumn = newColumns[destStatus as ValidColumnKey] as Column;
      const sourceTickets = [...sourceColumn.tickets];
      const destTickets = [...destColumn.tickets];

      sourceTickets.splice(source.index, 1);
      destTickets.splice(destination.index, 0, draggedTicket);

      (newColumns[sourceStatus as ValidColumnKey] as Column).tickets = sourceTickets;
      (newColumns[destStatus as ValidColumnKey] as Column).tickets = destTickets;
    }

    // Update UI immediately
    setColumns(newColumns);

    try {
      const targetColumn = sourceStatus === destStatus 
        ? newColumns[sourceStatus as ValidColumnKey] as Column
        : newColumns[destStatus as ValidColumnKey] as Column;
      
      const newOrder = calculateNewOrder(
        targetColumn.tickets[destination.index - 1]?.order || 0,
        targetColumn.tickets[destination.index + 1]?.order || targetColumn.tickets[destination.index - 1]?.order + 2000
      );

      const updates: Partial<Ticket> = { order: newOrder };
      if (sourceStatus !== destStatus) {
        updates.status = destStatus;
      }

      await updateTicket(draggedTicket.id, updates);
    } catch (error) {
      console.error('Failed to update ticket:', error);
      setFailedTicketId(draggedTicket.id);
      setColumns(columns); // Revert on error
      setTimeout(() => setFailedTicketId(null), 2000); // Clear error state after 2s
    }
  };

  // Helper function to calculate new order
  const calculateNewOrder = (prevOrder: number, nextOrder: number): number => {
    return prevOrder + (nextOrder - prevOrder) / 2;
  };

  const handleTicketClick = (ticket: Ticket) => {
    setSelectedTicket(ticket);
  };

  const handleMoveToBoard = async () => {
    if (!isBacklogColumns(columns)) return;
    
    const nextForDevTickets = columns.BACKLOG_DEV_NEXT.tickets;
    if (nextForDevTickets.length === 0) return;

    try {
      // Update all tickets in the column
      const updatePromises = nextForDevTickets.map((ticket: Ticket) =>
        updateTicket(ticket.id, {
          status: 'SELECTED_FOR_DEV' as TicketStatus,
          order: calculateNewOrder(0, 2000) // Place at the beginning of the new column
        })
      );

      await Promise.all(updatePromises);

      // Update local state
      const newColumns = { ...columns } as BacklogColumnsType;
      newColumns.BACKLOG_DEV_NEXT.tickets = [];
      setColumns(newColumns);
    } catch (error) {
      console.error('Failed to move tickets to board:', error);
    }
  };

  const organizeTicketsIntoColumns = useCallback((tickets: Ticket[]) => {
    // Create fresh columns with proper typing
    const newColumns = mode === 'development' 
      ? { ...developmentColumns } as DevelopmentColumnsType
      : { ...backlogColumns } as BacklogColumnsType;

    // Clear existing tickets
    if (isDevelopmentColumns(newColumns)) {
      Object.values(newColumns).forEach(column => {
        column.tickets = [];
      });
    } else if (isBacklogColumns(newColumns)) {
      Object.values(newColumns).forEach(column => {
        column.tickets = [];
      });
    }

    // Sort tickets by order
    const sortedTickets = [...tickets].sort((a, b) => (a.order || 0) - (b.order || 0));

    // Distribute tickets to columns
    sortedTickets.forEach(ticket => {
      if (isDevelopmentColumns(newColumns)) {
        if (ticket.status in newColumns) {
          newColumns[ticket.status as keyof DevelopmentColumnsType].tickets.push(ticket);
        }
      } else if (isBacklogColumns(newColumns)) {
        if (ticket.status in newColumns) {
          newColumns[ticket.status as keyof BacklogColumnsType].tickets.push(ticket);
        }
      }
    });

    return newColumns;
  }, [mode]);

  // Add useEffect to listen for tickets changes
  useEffect(() => {
    const loadTickets = async () => {
      if (!currentAccount?.id) return;
      
      try {
        const ticketsData = await getTickets();
        setTickets(ticketsData);
        const newColumns = organizeTicketsIntoColumns(ticketsData);
        setColumns(newColumns);
      } catch (error) {
        console.error('Error loading tickets:', error);
      }
    };

    loadTickets();
  }, [currentAccount?.id, getTickets, organizeTicketsIntoColumns]);

  // Update refreshTickets to use the new helper
  const refreshTickets = useCallback(async () => {
    if (!currentAccount?.id) return;
    
    try {
      const ticketsData = await getTickets();
      console.log('[TicketBoard] Refreshing tickets:', ticketsData);
      const newColumns = organizeTicketsIntoColumns(ticketsData);
      setColumns(newColumns);
    } catch (error) {
      console.error('Error refreshing tickets:', error);
    }
  }, [currentAccount?.id, getTickets, organizeTicketsIntoColumns]);

  const refreshBoard = useCallback(async () => {
    if (!currentAccount?.id) return;
    
    try {
      const ticketsData = await getTickets();
      setTickets(ticketsData);
      const newColumns = organizeTicketsIntoColumns(ticketsData);
      setColumns(newColumns);
    } catch (error) {
      console.error('Error refreshing tickets:', error);
    }
  }, [currentAccount?.id, getTickets, organizeTicketsIntoColumns]);

  // Update modal handlers
  const handleModalClose = () => {
    setSelectedTicket(undefined);
    setIsCreateModalOpen(false);
  };

  const handleModalSave = async () => {
    await refreshTickets();
    handleModalClose();
  };

  return (
    <div className={`
      flex flex-col h-full
      bg-white dark:bg-[${theme.colors.dark.background.primary}]
    `}>
      <header className={commonStyles.header.wrapper}>
        <div className={commonStyles.header.container}>
          <div className={commonStyles.header.titleWrapper}>
            <h2 className={commonStyles.header.title}>{title}</h2>
            <p className={commonStyles.header.subtitle}>{subtitle}</p>
          </div>
          <div className={commonStyles.header.actions}>
            <button
              onClick={() => setIsCreateModalOpen(true)}
              className={`
                ${commonStyles.button.base} 
                ${commonStyles.button.primary}
              `}
            >
              <Plus className="w-4 h-4" />
              Create Ticket
            </button>
          </div>
        </div>
      </header>

      {/* Board */}
      <DragDropContext onDragEnd={handleDragEnd}>
        <div className={`
          ${layout.grid.cols4}
          min-h-[calc(100vh-12rem)]
          overflow-x-auto
          gap-4 lg:gap-6
          p-6
          bg-white dark:bg-[${theme.colors.dark.background.primary}]
        `}>
          {Object.entries(columns).map(([status, column]) => (
            <Droppable droppableId={status} key={`column-${status}`}>
              {(provided, snapshot) => (
                <div
                  ref={provided.innerRef}
                  {...provided.droppableProps}
                  className={`
                    rounded-lg
                    ${snapshot.isDraggingOver ? `ring-2 ring-blue-500/20 dark:bg-[${theme.colors.dark.background.hover}]` : ''}
                    bg-white dark:bg-[${theme.colors.dark.primary}]
                    border border-gray-200 dark:border-gray-700
                    p-4
                    ${animations.transition.normal}
                  `}
                >
                  {/* Column Header */}
                  <div className={`${layout.flex.between} mb-4`}>
                    <h2 className={typography.h4}>{column.title}</h2>
                    <div className="flex items-center gap-2">
                      {/* Add Move to Board button for Next for Development column */}
                      {mode === 'backlog' && status === 'BACKLOG_DEV_NEXT' && (
                        <button
                          onClick={handleMoveToBoard}
                          className={`
                            ${commonStyles.button.base}
                            ${commonStyles.button.secondary}
                            text-sm
                          `}
                        >
                          Move to Board
                        </button>
                      )}
                      <span className={`
                        px-2.5 py-0.5 
                        rounded-full text-sm
                        bg-gray-100 dark:bg-gray-800
                        text-gray-600 dark:text-gray-400
                      `}>
                        {column.tickets.length}
                      </span>
                    </div>
                  </div>

                  {/* Tickets */}
                  <div className="space-y-3">
                    {column.tickets.map((ticket, index) => (
                      <Draggable
                        key={`${ticket.id}-${status}`}
                        draggableId={ticket.id}
                        index={index}
                      >
                        {(provided, snapshot) => (
                          <div
                            ref={provided.innerRef}
                            {...provided.draggableProps}
                            {...provided.dragHandleProps}
                            onClick={() => setSelectedTicket(ticket)}
                            className={`
                              ${commonStyles.card}
                              ${snapshot.isDragging ? 'ring-2 ring-blue-500/20 shadow-lg' : ''}
                              bg-white dark:bg-[${theme.colors.dark.background.primary}]
                              hover:shadow-md dark:hover:bg-[${theme.colors.dark.background.hover}]
                              cursor-pointer
                              p-4
                              ${failedTicketId === ticket.id ? 'opacity-50' : ''}
                            `}
                          >
                            {/* Ticket Content */}
                            <div className="space-y-2">
                              <div className="flex items-start gap-2">
                                <span className="text-sm font-medium text-gray-400 dark:text-gray-500 whitespace-nowrap">
                                  {ticket.ticket_id}
                                </span>
                                <span className="text-gray-900 dark:text-gray-100 line-clamp-2">
                                  {ticket.title}
                                </span>
                              </div>
                              
                              <div className={`${layout.flex.between} gap-2 flex-wrap`}>
                                <div className="flex gap-2 items-center">
                                  {/* Type Badge */}
                                  <span className={`
                                    px-2 py-1 rounded-md text-xs font-medium
                                    ${(ticket.type || 'task') === 'bug' 
                                      ? 'bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400'
                                      : (ticket.type || 'task') === 'story'
                                      ? 'bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400'
                                      : 'bg-gray-100 text-gray-700 dark:bg-gray-900/30 dark:text-gray-400'
                                    }
                                  `}>
                                    {(ticket.type || 'task').charAt(0).toUpperCase() + (ticket.type || 'task').slice(1)}
                                  </span>

                                  {/* Priority Badge */}
                                  <span className={`
                                    px-2 py-1 rounded-md text-xs font-medium
                                    ${ticket.priority === 'high' 
                                      ? 'bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400'
                                      : ticket.priority === 'medium'
                                      ? 'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-400'
                                      : 'bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400'
                                    }
                                  `}>
                                    {ticket.priority.charAt(0).toUpperCase() + ticket.priority.slice(1)}
                                  </span>
                                </div>

                                {/* Assignee */}
                                {ticket.assigneeId && (
                                  <span className={`
                                    ${typography.small}
                                    truncate max-w-[150px]
                                  `}>
                                    {getUserName(ticket.assigneeId)}
                                  </span>
                                )}
                              </div>
                            </div>
                          </div>
                        )}
                      </Draggable>
                    ))}
                    {provided.placeholder}
                  </div>

                  {/* Empty State */}
                  {column.tickets.length === 0 && (
                    <div className={`
                      ${layout.flex.center}
                      flex-col gap-2 p-6
                      text-gray-400 dark:text-gray-600
                    `}>
                      <AlertCircle className="w-5 h-5" />
                      <p className={typography.small}>No tickets</p>
                    </div>
                  )}
                </div>
              )}
            </Droppable>
          ))}
        </div>
      </DragDropContext>

      {/* Modals */}
      {selectedTicket && (
        <TicketModal
          ticket={selectedTicket}
          isOpen={!!selectedTicket}
          onClose={handleModalClose}
          onSave={refreshBoard}
        />
      )}
      <TicketModal
        isOpen={isCreateModalOpen}
        onClose={handleModalClose}
        onSave={handleModalSave}
      />
    </div>
  );
}

export default TicketBoard;


--- File: ./src/components/Tickets/TicketList.tsx ---

import { Table, TableBody, TableCell, TableContainer, TableHead, TablePagination, TableRow, Paper, TextField, InputAdornment, FormControl, Select, MenuItem, ListSubheader } from '@mui/material';
import React, { useState, useEffect } from 'react';
import { Ticket, TicketStatus } from '../../types/ticket';
import { useAuth } from '../../context/AuthContext';
import { useAccount } from '../../context/AccountContext';
import { Plus, AlertCircle, ArrowRight, Search } from 'lucide-react';
import TicketModal from './TicketModal';
import { theme, commonStyles, typography, layout, animations } from '../../styles';
import { useTickets } from '../../hooks/useTickets';
import { CustomUser } from '../../types/user';
import { subscribeToUsers } from '../../services/chat';

interface TicketListProps {
  showHeader?: boolean;
}

const formatDate = (timestamp: number | undefined) => {
  if (!timestamp) return '-';
  return new Date(timestamp).toLocaleDateString();
};

export function TicketList({ showHeader = true }: TicketListProps) {
  const [tickets, setTickets] = useState<Ticket[]>([]);
  const [selectedTicket, setSelectedTicket] = useState<Ticket | null>(null);
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterStatus, setFilterStatus] = useState<'all' | TicketStatus>('all');
  const { getTickets, updateTicket } = useTickets();
  const { user } = useAuth();
  const { currentAccount } = useAccount();
  const [users, setUsers] = useState<{ [key: string]: CustomUser }>({});

  useEffect(() => {
    const fetchTickets = async () => {
      const fetchedTickets = await getTickets();
      console.log('[TicketList] Fetched tickets:', fetchedTickets.length);
      setTickets(fetchedTickets);
    };

    fetchTickets();
  }, [getTickets]);

  useEffect(() => {
    if (!currentAccount?.id) {
      console.log('[TicketList] No current account, skipping users subscription');
      return;
    }

    const memberIds = Object.keys(currentAccount.members);
    console.log('[TicketList] Setting up users subscription for members:', memberIds);
    
    const unsubscribe = subscribeToUsers(
      currentAccount.id,
      memberIds,
      (fetchedUsers: { [key: string]: CustomUser }) => {
        console.log('[TicketList] Received users:', fetchedUsers);
        setUsers(fetchedUsers);
      }
    );

    return () => {
      console.log('[TicketList] Cleaning up users subscription');
      unsubscribe();
    };
  }, [currentAccount]);

  const getAssigneeName = (assigneeId: string | undefined) => {
    if (!assigneeId) return 'Unassigned';
    const user = users[assigneeId];
    return user ? (user.displayName || user.email || 'Unknown User') : 'Loading...';
  };

  const handleChangePage = (event: unknown, newPage: number) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event: React.ChangeEvent<HTMLInputElement>) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const filteredTickets = tickets.filter((ticket) => {
    const matchesSearch = 
      ticket.title?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      ticket.ticket_id?.toLowerCase().includes(searchTerm.toLowerCase());
    
    if (filterStatus === 'all') return matchesSearch;
    return matchesSearch && ticket.status === filterStatus;
  });

  const getStatusGroups = () => ({
    'Development Board': [
      'SELECTED_FOR_DEV',
      'IN_PROGRESS',
      'READY_FOR_TESTING',
      'DEPLOYED'
    ],
    'Backlog': [
      'BACKLOG_ICEBOX',
      'BACKLOG_NEW',
      'BACKLOG_REFINED',
      'BACKLOG_DEV_NEXT'
    ]
  });

  return (
    <div className="flex flex-col h-full bg-white dark:bg-gray-900">
      {showHeader && (
        <header className="mb-6 px-6 pt-6">
          <div className="flex justify-between items-center">
            <div>
              <h2 className="text-xl font-semibold text-gray-900 dark:text-white">All Tickets</h2>
              <p className="text-sm text-gray-500 dark:text-gray-400">Manage your tickets</p>
            </div>
            <button
              onClick={() => setIsCreateModalOpen(true)}
              className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors duration-150"
            >
              Create Ticket
            </button>
          </div>
        </header>
      )}

      <div className="p-6">
        <div className="mb-6 flex gap-4 items-center">
          <div className="flex-1">
            <TextField
              fullWidth
              size="small"
              placeholder="Search tickets..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="dark:bg-gray-800"
              sx={{
                '& .MuiOutlinedInput-root': {
                  '& fieldset': {
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                  },
                  '&:hover fieldset': {
                    borderColor: 'rgba(255, 255, 255, 0.2)',
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: 'rgba(255, 255, 255, 0.3)',
                  },
                },
                '& .MuiInputBase-input': {
                  color: 'inherit',
                },
              }}
              InputProps={{
                className: 'dark:text-white',
                startAdornment: (
                  <InputAdornment position="start">
                    <Search className="w-5 h-5 text-gray-400 dark:text-gray-500" />
                  </InputAdornment>
                ),
              }}
            />
          </div>
          <FormControl size="small" sx={{ minWidth: 200 }}>
            <Select
              value={filterStatus}
              onChange={(e) => setFilterStatus(e.target.value as 'all' | TicketStatus)}
              className="dark:bg-gray-800 dark:text-white"
              MenuProps={{
                PaperProps: {
                  className: 'dark:bg-gray-800',
                  sx: {
                    '& .MuiMenuItem-root': {
                      '&:hover': {
                        backgroundColor: 'rgba(255, 255, 255, 0.05)',
                      },
                    },
                    '& .MuiListSubheader-root': {
                      lineHeight: '32px',
                    },
                  },
                },
              }}
              sx={{
                '& .MuiOutlinedInput-notchedOutline': {
                  borderColor: 'rgba(255, 255, 255, 0.1)',
                },
                '&:hover .MuiOutlinedInput-notchedOutline': {
                  borderColor: 'rgba(255, 255, 255, 0.2)',
                },
                '&.Mui-focused .MuiOutlinedInput-notchedOutline': {
                  borderColor: 'rgba(255, 255, 255, 0.3)',
                },
              }}
            >
              <MenuItem value="all" className="dark:text-gray-200">All Status</MenuItem>
              {Object.entries(getStatusGroups()).map(([groupName, statuses]) => [
                <ListSubheader
                  key={groupName}
                  className="dark:bg-gray-700/50 dark:text-gray-100 bg-gray-200 text-gray-700 sticky top-0 z-10 font-medium border-t border-b dark:border-gray-600"
                >
                  {groupName}
                </ListSubheader>,
                ...statuses.map((status) => (
                  <MenuItem 
                    key={status} 
                    value={status}
                    className="dark:text-gray-200 dark:hover:bg-gray-700 dark:bg-gray-800"
                  >
                    {status.split('_').map(word => 
                      word.charAt(0) + word.slice(1).toLowerCase()
                    ).join(' ')}
                  </MenuItem>
                ))
              ])}
            </Select>
          </FormControl>
        </div>

        {filteredTickets.length > 0 ? (
          <TableContainer 
            component={Paper} 
            className="bg-white dark:bg-gray-800 shadow-sm"
            sx={{
              backgroundColor: 'inherit',
              '& .MuiPaper-root': {
                backgroundColor: 'inherit',
              },
            }}
          >
            <Table>
              <TableHead>
                <TableRow className="bg-gray-50 dark:bg-gray-700">
                  <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">Status</TableCell>
                  <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">Ticket ID</TableCell>
                  <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">Title</TableCell>
                  <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">Priority</TableCell>
                  <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">Assignee</TableCell>
                  <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">Created</TableCell>
                  <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">Updated</TableCell>
                </TableRow>
              </TableHead>
              <TableBody className="dark:bg-gray-800">
                {filteredTickets.slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage).map((ticket) => (
                  <TableRow
                    key={ticket.id}
                    onClick={() => setSelectedTicket(ticket)}
                    className="
                      cursor-pointer
                      hover:bg-gray-50 dark:hover:bg-gray-700
                      transition-colors duration-150
                      border-b dark:border-gray-700
                    "
                  >
                    <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">{ticket.status}</TableCell>
                    <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600 font-medium">{ticket.ticket_id}</TableCell>
                    <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">{ticket.title}</TableCell>
                    <TableCell className="border-b dark:border-gray-600">
                      <span className={`
                        px-2 py-1 rounded-full text-sm font-medium
                        ${ticket.priority === 'high' ? 'bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400' : ''}
                        ${ticket.priority === 'medium' ? 'bg-yellow-100 dark:bg-yellow-900/30 text-yellow-700 dark:text-yellow-400' : ''}
                        ${ticket.priority === 'low' ? 'bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400' : ''}
                      `}>
                        {ticket.priority}
                      </span>
                    </TableCell>
                    <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">{getAssigneeName(ticket.assigneeId)}</TableCell>
                    <TableCell className="text-gray-600 dark:text-gray-400 border-b dark:border-gray-600">{formatDate(ticket.createdAt)}</TableCell>
                    <TableCell className="text-gray-600 dark:text-gray-400 border-b dark:border-gray-600">{formatDate(ticket.updatedAt)}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
            <TablePagination
              rowsPerPageOptions={[5, 10, 25]}
              component="div"
              count={filteredTickets.length}
              rowsPerPage={rowsPerPage}
              page={page}
              onPageChange={handleChangePage}
              onRowsPerPageChange={handleChangeRowsPerPage}
              className="text-gray-900 dark:text-gray-100"
              sx={{
                '.MuiTablePagination-select': {
                  color: 'inherit',
                },
                '.MuiTablePagination-selectIcon': {
                  color: 'inherit',
                },
                '.MuiTablePagination-displayedRows': {
                  color: 'inherit',
                },
                '.MuiIconButton-root': {
                  color: 'inherit',
                },
              }}
            />
          </TableContainer>
        ) : (
          <div className={`
            ${layout.flex.center}
            flex-col gap-2 p-6
            text-gray-400 dark:text-[${theme.colors.dark.text.muted}]
          `}>
            <AlertCircle className="w-5 h-5" />
            <p className={typography.small}>No tickets</p>
          </div>
        )}
      </div>

      {selectedTicket && (
        <TicketModal
          ticket={selectedTicket}
          isOpen={!!selectedTicket}
          onClose={() => setSelectedTicket(null)}
          onSave={getTickets}
        />
      )}
      <TicketModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
      />
    </div>
  );
}

const getPriorityStyles = (priority: string) => {
  switch (priority) {
    case 'high':
      return 'bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400';
    case 'medium':
      return 'bg-yellow-100 dark:bg-yellow-900/30 text-yellow-700 dark:text-yellow-400';
    case 'low':
      return 'bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400';
    default:
      return 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-400';
  }
};

export default TicketList;


--- File: ./src/components/Tickets/TicketsContainer.tsx ---

import React, { useState } from 'react';
import TicketList from './TicketList';
import { TicketBoard } from './TicketBoard';
import TicketViewSwitch from './TicketViewSwitch';
import { Link } from 'react-router-dom';
import { Plus } from 'lucide-react';

type ViewType = 'list' | 'board';

export function TicketsContainer() {
  const [view, setView] = useState<ViewType>('list');

  return (
    <div className="flex flex-col h-full">
      <div className="border-b border-gray-200 dark:border-gray-700">
        <div className="p-4 flex items-center justify-between">
          <h1 className="text-2xl font-bold">Tickets</h1>
          <div className="flex space-x-2">
            <button
              onClick={() => setView('list')}
              className={`px-4 py-2 rounded-lg ${
                view === 'list' 
                  ? 'bg-blue-500 text-white' 
                  : 'bg-gray-100 text-gray-700 dark:bg-gray-700 dark:text-gray-300'
              }`}
            >
              List
            </button>
            <button
              onClick={() => setView('board')}
              className={`px-4 py-2 rounded-lg ${
                view === 'board' 
                  ? 'bg-blue-500 text-white' 
                  : 'bg-gray-100 text-gray-700 dark:bg-gray-700 dark:text-gray-300'
              }`}
            >
              Board
            </button>
          </div>
        </div>
      </div>
      {view === 'list' ? <TicketList showHeader={false} /> : <TicketBoard />}
    </div>
  );
}


--- File: ./src/components/Tickets/TicketModal.tsx ---

import React, { useState, useEffect, useRef } from 'react';
import { doc, updateDoc, collection, addDoc, getDocs, query, where, writeBatch, orderBy, limit, getDoc } from 'firebase/firestore';
import { db } from '../../services/firebase';
import { Ticket, TicketStatus, TicketPriority, TicketType } from '../../types/ticket';
import { CustomUser } from '../../types/user';
import { useAuth } from '../../context/AuthContext';
import { theme, commonStyles, typography, layout, animations } from '../../styles';
import { X, Loader, Copy, Check, Trash2 } from 'lucide-react';
import { Modal } from 'react-responsive-modal';
import 'react-responsive-modal/styles.css';
import ReactMarkdown from 'react-markdown';
import { PrismAsyncLight as SyntaxHighlighter } from 'react-syntax-highlighter';
import { tomorrow } from 'react-syntax-highlighter/dist/esm/styles/prism';
import { Components } from 'react-markdown';
import { useAccount } from '../../context/AccountContext';
import { useTickets } from '../../hooks/useTickets';
import { 
  COLUMN_STATUS_LABELS,
  BacklogStatus,
  BoardStatus
} from '../../types/board';

// Define the CodeProps interface directly
interface CodeProps {
  node?: any;
  inline?: boolean;
  className?: string;
  children?: React.ReactNode;
}

interface TicketModalProps {
  ticket?: Ticket;
  isOpen: boolean;
  onClose: () => void;
  onSave?: () => void;
}

const DEFAULT_STATUS: TicketStatus = 'BACKLOG_NEW';
const DEFAULT_PRIORITY: TicketPriority = 'medium';

const TICKET_STATUS_LABELS: Record<TicketStatus, string> = COLUMN_STATUS_LABELS;

// Define the backlog and development status options
const BACKLOG_OPTIONS: BacklogStatus[] = [
  'BACKLOG_ICEBOX',
  'BACKLOG_NEW',
  'BACKLOG_REFINED',
  'BACKLOG_DEV_NEXT'
];

const DEVELOPMENT_OPTIONS: BoardStatus[] = [
  'SELECTED_FOR_DEV',
  'IN_PROGRESS',
  'READY_FOR_TESTING',
  'DEPLOYED'
];

export default function TicketModal({ ticket, isOpen, onClose, onSave }: TicketModalProps) {
  const { user } = useAuth();
  const { currentAccount } = useAccount();
  const { createTicket, updateTicket, deleteTicket } = useTickets();
  const [title, setTitle] = useState(ticket?.title || '');
  const [description, setDescription] = useState(ticket?.description || '');
  const [status, setStatus] = useState<TicketStatus>(ticket?.status || DEFAULT_STATUS);
  const [priority, setPriority] = useState<TicketPriority>(ticket?.priority || DEFAULT_PRIORITY);
  const [assigneeId, setAssigneeId] = useState(ticket?.assigneeId || '');
  const [loading, setLoading] = useState(false);
  const [users, setUsers] = useState<{[key: string]: CustomUser}>({});
  const [error, setError] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);
  const [ticketType, setTicketType] = useState<TicketType>(ticket?.type || 'task');

  // Check authorization
  const isAuthorized = React.useMemo(() => {
    if (!user || !currentAccount) return false;
    
    // For new tickets, check if user is in current account
    if (!ticket) {
      return currentAccount.members[user.uid] != null;
    }
    
    // For existing tickets, check if ticket belongs to current account
    return ticket.accountId === currentAccount.id && currentAccount.members[user.uid] != null;
  }, [user, currentAccount, ticket]);

  // Redirect or close if not authorized
  useEffect(() => {
    if (isOpen && !isAuthorized) {
      console.log('[TicketModal] Unauthorized access, closing modal');
      onClose();
    }
  }, [isOpen, isAuthorized, onClose]);

  // Fetch users for the assignee dropdown
  useEffect(() => {
    const fetchUsers = async () => {
      if (!currentAccount) return;
      
      try {
        const userPromises = Object.keys(currentAccount.members).map(async (userId) => {
          try {
            const userDoc = await getDoc(doc(db, 'users', userId));
            if (userDoc.exists()) {
              return { userId, userData: userDoc.data() as CustomUser };
            }
          } catch (error) {
            console.error(`Failed to load user ${userId}:`, error);
          }
          return null;
        });

        const usersData = await Promise.all(userPromises);
        const newUsers: Record<string, CustomUser> = {};
        
        usersData.forEach(user => {
          if (user) {
            newUsers[user.userId] = user.userData;
          }
        });

        setUsers(newUsers);
      } catch (error) {
        console.error('Failed to load users:', error);
      }
    };

    fetchUsers();
  }, [currentAccount]);

  // Update form when ticket changes
  useEffect(() => {
    setTitle(ticket?.title || '');
    setDescription(ticket?.description || '');
    setStatus(ticket?.status || DEFAULT_STATUS);
    setPriority(ticket?.priority || DEFAULT_PRIORITY);
    setAssigneeId(ticket?.assigneeId || '');
    setTicketType(ticket?.type || 'task');
  }, [ticket]);

  const getUserName = (userId: string) => {
    const userInfo = users[userId];
    return userInfo?.displayName || userInfo?.email || 'Unknown User';
  };

  const getNextTicketNumber = async () => {
    if (!currentAccount?.id) {
      console.error('[TicketModal] No current account when generating ticket number');
      return 'Q-001'; // Fallback
    }
    
    const prefix = 'Q';
    
    try {
      // Get all tickets for this account to ensure we don't miss any
      const ticketsRef = collection(db, 'tickets');
      const q = query(
        ticketsRef,
        where('accountId', '==', currentAccount.id),
        where('ticket_id', '>=', 'Q-'), // Ensure we only get Q- prefixed tickets
        orderBy('ticket_id', 'desc')  // Remove limit to get all tickets
      );
      
      console.log('[TicketModal] Querying for last ticket number');
      const snapshot = await getDocs(q);
      let maxNumber = 0;
      
      // Iterate through all tickets to find the highest number
      snapshot.forEach((doc) => {
        const ticketData = doc.data();
        if (ticketData.ticket_id) {
          const match = ticketData.ticket_id.match(/Q-(\d{3})/);
          if (match) {
            const number = parseInt(match[1], 10);
            maxNumber = Math.max(maxNumber, number);
          }
        }
      });

      console.log('[TicketModal] Highest ticket number found:', maxNumber);
      const nextNumber = maxNumber + 1;
      const newTicketId = `${prefix}-${String(nextNumber).padStart(3, '0')}`;
      
      console.log('[TicketModal] Generated new ticket ID:', newTicketId);
      return newTicketId;
      
    } catch (error) {
      console.error('[TicketModal] Error generating ticket number:', error);
      return 'Q-001'; // Fallback in case of error
    }
  };

  // Handle submit with authorization check
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!user || !currentAccount || !isAuthorized) {
      console.error('[TicketModal] Unauthorized attempt to save ticket');
      setError('You do not have permission to perform this action');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      if (ticket?.id) {
        // Update existing ticket
        await updateTicket(ticket.id, {
          title,
          description,
          status,
          priority,
          assigneeId,
          type: ticketType,
          updatedAt: Date.now(),
        });
      } else {
        // Create new ticket
        const nextTicketId = await getNextTicketNumber();
        
        // Double check that this ticket ID doesn't already exist
        const ticketsRef = collection(db, 'tickets');
        const existingTicketQuery = query(
          ticketsRef,
          where('accountId', '==', currentAccount.id),
          where('ticket_id', '==', nextTicketId)
        );
        
        const existingTicket = await getDocs(existingTicketQuery);
        if (!existingTicket.empty) {
          throw new Error('Duplicate ticket ID generated. Please try again.');
        }

        const newTicket = await createTicket({
          title,
          description,
          status,
          priority,
          assigneeId,
          type: ticketType,
          updatedAt: Date.now(),
          createdBy: user.uid,
          createdAt: Date.now(),
          order: Date.now(),
          ticket_id: nextTicketId,
        });
        
        if (!newTicket) {
          throw new Error('Failed to create ticket');
        }
      }

      await onSave?.();
      onClose();
    } catch (error) {
      console.error('[TicketModal] Error saving ticket:', error);
      setError(error instanceof Error ? error.message : 'Failed to save ticket. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Adjust height whenever entering edit mode or content changes
  const adjustTextareaHeight = () => {
    const textarea = textareaRef.current;
    if (textarea) {
      // Reset height to auto first
      textarea.style.height = 'auto';
      // Then set to scrollHeight to match content
      textarea.style.height = `${Math.max(300, textarea.scrollHeight)}px`;
      console.log('Adjusting height to:', textarea.scrollHeight); // Debug log
    }
  };

  // Call adjust height when entering edit mode
  const handlePreviewClick = () => {
    setIsEditing(true);
    // Focus and adjust height after the textarea is rendered
    setTimeout(() => {
      if (textareaRef.current) {
        textareaRef.current.focus();
        adjustTextareaHeight();
      }
    }, 0);
  };

  // Call adjust height when content changes
  useEffect(() => {
    if (isEditing) {
      adjustTextareaHeight();
    }
  }, [description, isEditing]);

  // Handle content changes
  const handleDescriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setDescription(e.target.value);
    adjustTextareaHeight();
  };

  const handleEditBlur = () => {
    setIsEditing(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    const target = e.target as HTMLTextAreaElement;
    const cursorPosition = target.selectionStart;
    const currentLine = target.value.slice(0, cursorPosition).split('\n').pop() || '';
    
    // Only add closing backticks if the current line is exactly ```
    if (currentLine === '```' && e.key === 'Enter') {
      e.preventDefault();
      const textBeforeCursor = target.value.slice(0, cursorPosition);
      const textAfterCursor = target.value.slice(cursorPosition);
      
      const newValue = textBeforeCursor + '\n\n```' + textAfterCursor;
      setDescription(newValue);
      
      // Move cursor between the backticks
      setTimeout(() => {
        if (textareaRef.current) {
          const newPosition = cursorPosition + 1; // Position after the first newline
          textareaRef.current.setSelectionRange(newPosition, newPosition);
        }
      }, 0);
    }
  };

  // Add this helper function
  const CopyButton = ({ text }: { text: string }) => {
    const [copied, setCopied] = useState(false);

    const handleCopy = async (e: React.MouseEvent) => {
      // Prevent the click from bubbling up to the preview div and modal
      e.stopPropagation();
      e.preventDefault();
      
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    };

    return (
      <button
        onClick={handleCopy}
        onMouseDown={(e) => e.preventDefault()} // Prevent modal close on mousedown
        className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
        title="Copy code"
      >
        {copied ? (
          <Check className="h-4 w-4" />
        ) : (
          <Copy className="h-4 w-4" />
        )}
      </button>
    );
  };

  // Add this component for rendering the description preview
  const DescriptionPreview = ({ text }: { text: string }) => {
    // Function to convert URLs in text to markdown links
    const addMarkdownLinks = (text: string) => {
      const urlRegex = /(https?:\/\/[^\s]+)/g;
      return text.replace(urlRegex, (url) => `[${url}](${url})`);
    };

    return (
      <ReactMarkdown
        components={{
          code({ node, inline, className, children, ...props }: CodeProps) {
            const match = /language-(\w+)/.exec(className || '');
            const language = match ? match[1] : 'text';
            
            return !inline ? (
              <div className="relative group" onClick={(e) => e.stopPropagation()}>
                <div className="absolute right-2 top-2 flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                  {language && (
                    <span className="text-xs text-gray-500 dark:text-gray-400 bg-gray-100 dark:bg-gray-700 rounded px-2 py-1">
                      {language}
                    </span>
                  )}
                  <CopyButton text={String(children).replace(/\n$/, '')} />
                </div>
                <SyntaxHighlighter
                  style={tomorrow as any}
                  language={language}
                  PreTag="div"
                  customStyle={{}}
                  className="rounded-md !mt-0"
                  {...props}
                >
                  {String(children).replace(/\n$/, '')}
                </SyntaxHighlighter>
              </div>
            ) : (
              <code className="px-1 py-0.5 rounded-sm bg-gray-100 dark:bg-gray-700 text-sm" {...props}>
                {children}
              </code>
            );
          },
          a({ node, children, href, ...props }) {
            return (
              <a
                href={href}
                target="_blank"
                rel="noopener noreferrer"
                className="text-blue-500 hover:text-blue-600 dark:text-blue-400 dark:hover:text-blue-300 underline"
                onClick={(e) => {
                  e.stopPropagation(); // Prevent edit mode activation
                }}
                {...props}
              >
                {children}
              </a>
            );
          }
        }}
      >
        {addMarkdownLinks(text)}
      </ReactMarkdown>
    );
  };

  const placeholderText = 
`Description supports markdown and code blocks:

# Heading 1
## Heading 2

- Bullet points
- Another point

Start a code block with \`\`\` and press Enter:

\`\`\`javascript
const hello = 'world';
console.log(hello);
\`\`\`

Text after the code block.

**Bold text** and *italic text*

You can also use \`inline code\` with single backticks.`;

  // Add delete handler
  const handleDelete = async () => {
    if (!ticket?.id) return;
    
    setLoading(true);
    setError(null);

    try {
      await deleteTicket(ticket.id);
      await onSave?.();
      onClose();
    } catch (error) {
      console.error('[TicketModal] Error deleting ticket:', error);
      setError('Failed to delete ticket. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Add delete confirmation modal
  const DeleteConfirmation = () => (
    <Modal
      open={isDeleteConfirmOpen}
      onClose={() => setIsDeleteConfirmOpen(false)}
      center
      classNames={{
        modal: 'bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6',
        overlay: 'bg-black bg-opacity-50'
      }}
    >
      <div className="space-y-4">
        <h3 className={typography.h3}>Delete Ticket</h3>
        <p className="text-gray-600 dark:text-gray-400">
          Are you sure you want to delete ticket {ticket?.ticket_id}? This action cannot be undone.
        </p>
        <div className="flex justify-end gap-3 pt-4">
          <button
            onClick={() => setIsDeleteConfirmOpen(false)}
            className={`${commonStyles.button.base} ${commonStyles.button.secondary}`}
          >
            Cancel
          </button>
          <button
            onClick={handleDelete}
            disabled={loading}
            className={`
              ${commonStyles.button.base} 
              ${commonStyles.button.danger}
              disabled:opacity-50
            `}
          >
            {loading ? (
              <span className={layout.flex.center}>
                <Loader className="w-4 h-4 animate-spin mr-2" />
                Deleting...
              </span>
            ) : (
              'Delete Ticket'
            )}
          </button>
        </div>
      </div>
    </Modal>
  );

  // Don't render anything if not authorized
  if (!isAuthorized) {
    return null;
  }

  return (
    <Modal
      open={isOpen && isAuthorized}
      onClose={onClose}
      center
      closeIcon={<></>}
      styles={{
        modal: {
          maxWidth: '90%',
          width: '90%',
        }
      }}
      classNames={{
        modal: 'bg-white dark:bg-gray-800 rounded-lg shadow-xl',
        overlay: 'bg-black bg-opacity-50'
      }}
    >
      <div className="p-6">
        <div className="flex justify-between items-start mb-6">
          <div className="flex-1">
            <h2 className="text-xl font-semibold text-gray-900 dark:text-gray-100">
              {ticket?.ticket_id || 'New Ticket'}
            </h2>
            <p className="text-lg text-gray-700 dark:text-gray-300 mt-1">
              {ticket?.title || ''}
            </p>
          </div>
          <button
            onClick={onClose}
            className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-full"
          >
            <X className="w-5 h-5 text-gray-500 dark:text-gray-400" />
          </button>
        </div>

        <form id="ticketForm" onSubmit={handleSubmit} className="flex gap-8">
          <div className="flex-[3] space-y-6">
            <div>
              <label className={`block mb-2 ${typography.small}`}>
                Title
              </label>
              <input
                type="text"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                className={`${commonStyles.input} w-full`}
                required
              />
            </div>

            <div>
              <label className={`block mb-2 ${typography.small}`}>
                Description
              </label>
              <div className="relative border rounded-md dark:border-gray-700">
                {isEditing ? (
                  <textarea
                    ref={textareaRef}
                    value={description}
                    onChange={handleDescriptionChange}
                    onBlur={handleEditBlur}
                    onKeyDown={handleKeyDown}
                    className={`
                      ${commonStyles.input} 
                      w-full
                      min-h-[300px]
                      font-mono text-sm 
                      resize-none
                      border-none
                      focus:ring-0
                      overflow-hidden
                    `}
                    placeholder={placeholderText}
                    required
                  />
                ) : (
                  <div 
                    onClick={handlePreviewClick}
                    className={`
                      p-4 min-h-[300px] cursor-text
                      ${description ? '' : 'text-gray-400 dark:text-gray-500'}
                    `}
                  >
                    {description ? (
                      <div className="prose dark:prose-invert max-w-none">
                        <DescriptionPreview text={description} />
                      </div>
                    ) : (
                      <p>Click to add description...</p>
                    )}
                  </div>
                )}
              </div>
            </div>
          </div>

          <div className="flex-1 space-y-6">
            <div>
              <label className={`block mb-2 ${typography.small}`}>
                Type
              </label>
              <select
                value={ticketType}
                onChange={(e) => setTicketType(e.target.value as TicketType)}
                className={commonStyles.input}
              >
                <option value="bug">Bug</option>
                <option value="task">Task</option>
                <option value="story">Story</option>
              </select>
            </div>

            <div>
              <label className={`block mb-2 ${typography.small}`}>
                Status
              </label>
              <select
                value={status}
                onChange={(e) => setStatus(e.target.value as TicketStatus)}
                className={commonStyles.input}
              >
                <optgroup label="Backlog">
                  {BACKLOG_OPTIONS.map((value) => (
                    <option key={value} value={value}>
                      {COLUMN_STATUS_LABELS[value]}
                    </option>
                  ))}
                </optgroup>
                <optgroup label="Development">
                  {DEVELOPMENT_OPTIONS.map((value) => (
                    <option key={value} value={value}>
                      {COLUMN_STATUS_LABELS[value]}
                    </option>
                  ))}
                </optgroup>
              </select>
            </div>

            <div>
              <label className={`block mb-2 ${typography.small}`}>
                Priority
              </label>
              <select
                value={priority}
                onChange={(e) => setPriority(e.target.value as TicketPriority)}
                className={commonStyles.input}
              >
                <option value="low">Low</option>
                <option value="medium">Medium</option>
                <option value="high">High</option>
              </select>
            </div>

            <div>
              <label className={`block mb-2 ${typography.small}`}>
                Assigned To
              </label>
              <select
                value={assigneeId}
                onChange={(e) => setAssigneeId(e.target.value)}
                className={commonStyles.input}
              >
                <option value="">Unassigned</option>
                {Object.entries(users).map(([userId, userInfo]) => (
                  <option key={userId} value={userId}>
                    {userInfo.displayName || userInfo.email || 'Unknown User'}
                  </option>
                ))}
              </select>
            </div>

            <div className="pt-4 border-t border-gray-200 dark:border-gray-700">
              <div className={typography.small}>
                Created by: {ticket?.createdBy ? getUserName(ticket.createdBy) : user?.email}
              </div>
              {ticket?.createdAt && (
                <div className={`mt-1 ${typography.small}`}>
                  Created: {new Date(ticket.createdAt).toLocaleDateString()}
                </div>
              )}
              {ticket?.updatedAt && (
                <div className={`mt-1 ${typography.small}`}>
                  Last updated: {new Date(ticket.updatedAt).toLocaleDateString()}
                </div>
              )}
            </div>
          </div>
        </form>

        <div className="flex justify-between gap-3 mt-6 pt-6 border-t border-gray-200 dark:border-gray-700">
          {/* Add delete button (only show for existing tickets) */}
          {ticket?.id && (
            <button
              type="button"
              onClick={() => setIsDeleteConfirmOpen(true)}
              className={`
                ${commonStyles.button.base} 
                ${commonStyles.button.danger}
              `}
            >
              <Trash2 className="w-4 h-4 mr-2" />
              Delete Ticket
            </button>
          )}
          
          <div className="flex gap-3">
            <button
              type="button"
              onClick={onClose}
              className={`${commonStyles.button.base} ${commonStyles.button.secondary}`}
            >
              Cancel
            </button>
            <button
              type="submit"
              form="ticketForm"
              disabled={loading}
              className={`
                ${commonStyles.button.base} 
                ${commonStyles.button.primary}
                disabled:opacity-50
              `}
            >
              {loading ? (
                <span className={layout.flex.center}>
                  <Loader className="w-4 h-4 animate-spin mr-2" />
                  Saving...
                </span>
              ) : (
                'Save Changes'
              )}
            </button>
          </div>
        </div>
      </div>
      
      {/* Render delete confirmation modal */}
      <DeleteConfirmation />
    </Modal>
  );
}



--- File: ./src/components/Codebase/Connect.tsx ---

import React, { useState, useEffect, useMemo } from 'react';
import { Github, ChevronDown, Loader2, Settings, Search } from "lucide-react";
import { theme, commonStyles } from '../../styles/theme';
import { githubService, GitHubRepo } from '../../services/github';
import { useAuth } from '../../context/AuthContext';
import { db } from '../../services/firebase';
import { doc, onSnapshot } from 'firebase/firestore';
import { syncRepository } from '../../services/api';
import { useCodebase } from '../../context/CodebaseContext';
import { useNavigate } from 'react-router-dom';

// Define the status type as a const array
const SYNC_STATUSES = ['idle', 'syncing', 'completed', 'failed'] as const;
type SyncStatusType = typeof SYNC_STATUSES[number];

// Add interface for the Python script response
interface SyncResponse {
  message: string;
  data: {
    status: string;
    repository: {
      name: string;
      full_name: string;
      description: string | null;
      default_branch: string;
    };
  };
}

interface SyncStatus {
  status: 'idle' | 'syncing' | 'completed' | 'failed';
  lastSynced?: Date;
  fileCount?: number;
  filesProcessed?: number;
  error?: string;
  repositoryDetails?: {
    name: string;
    description: string | null;
    default_branch: string;
  };
}

export default function Connect() {
  const { user } = useAuth();
  const [isConnected, setIsConnected] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [repositories, setRepositories] = useState<GitHubRepo[]>([]);
  const [selectedRepo, setSelectedRepo] = useState<GitHubRepo | null>(null);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [syncStatus, setSyncStatus] = useState<SyncStatus>({ status: 'idle' });
  const { setSelectedRepository } = useCodebase();
  const navigate = useNavigate();

  useEffect(() => {
    const loadGitHubStatus = async () => {
      if (user?.uid) {
        try {
          const token = await githubService.getToken(user.uid);
          if (token) {
            setIsConnected(true);
            // Fetch repositories when connected
            const repos = await githubService.fetchUserRepositories(user.uid);
            setRepositories(repos);
          }
        } catch (err) {
          console.error('Error loading GitHub status:', err);
          setError('Failed to load GitHub connection status');
        } finally {
          setIsLoading(false);
        }
      }
    };

    loadGitHubStatus();
  }, [user]);

  // Filter repositories based on search query
  const filteredRepositories = useMemo(() => {
    return repositories.filter(repo => 
      repo.full_name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      (repo.description?.toLowerCase() || '').includes(searchQuery.toLowerCase())
    );
  }, [repositories, searchQuery]);

  // Listen to sync status updates
  useEffect(() => {
    if (selectedRepo && user?.uid) {
      const repoId = selectedRepo.full_name.replace('/', '_');
      const unsubscribe = onSnapshot(
        doc(db, 'repositories', repoId),
        (doc) => {
          if (doc.exists()) {
            const data = doc.data();
            setSyncStatus({
              status: data.metadata.sync_status,
              lastSynced: data.metadata.last_synced?.toDate(),
              fileCount: data.metadata.file_count,
              filesProcessed: data.metadata.files_processed,
              error: data.metadata.error
            });
          }
        }
      );

      return () => unsubscribe();
    }
  }, [selectedRepo, user]);

  const handleRetrieveRepository = async () => {
    if (!selectedRepo || !user?.uid) return;

    try {
      setIsLoading(true);
      setError(null);
      console.log('Starting repository sync...', {
        repo: selectedRepo.full_name,
        userId: user.uid
      });

      // Update UI to show syncing state
      setSyncStatus({ status: 'syncing' });

      const response = await fetch('http://localhost:3001/api/repository/sync', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          repositoryName: selectedRepo.full_name,
          userId: user.uid
        }),
      });

      console.log('Response received:', response.status);
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to start repository sync');
      }

      const data: SyncResponse = await response.json();
      console.log('Sync response:', data);

      if (data.data.status === 'success') {
        setSyncStatus({
          status: 'completed',
          lastSynced: new Date(),
          repositoryDetails: data.data.repository
        });
      } else {
        throw new Error('Repository sync failed');
      }

    } catch (err) {
      console.error('Error starting repository sync:', err);
      setError('Failed to start repository sync. Please try again.');
      setSyncStatus({ 
        status: 'failed', 
        error: err instanceof Error ? err.message : 'Unknown error occurred'
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleRepositorySelect = (repoName: string) => {
    setSelectedRepository(repoName);
    navigate(`/codebase/files/${repoName}`);
  };

  const renderSyncStatus = () => {
    switch (syncStatus.status) {
      case 'syncing':
        return (
          <div className="space-y-2">
            <div className="flex items-center gap-2 text-blue-500 dark:text-blue-400">
              <Loader2 className="h-5 w-5 animate-spin" />
              <span>Syncing repository...</span>
              {syncStatus.filesProcessed && (
                <span className="text-sm">({syncStatus.filesProcessed} files processed)</span>
              )}
            </div>
            {/* Add restart button if sync takes too long */}
            <button
              onClick={handleRetrieveRepository}
              className="text-sm text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300 underline mt-2"
            >
              Restart Sync
            </button>
          </div>
        );
      case 'completed':
        return (
          <div className="space-y-2">
            <div className="text-green-500 dark:text-green-400">
              <p className="flex items-center gap-2 mb-2">
                <span className="text-lg">âœ“</span>
                Sync completed
              </p>
              {syncStatus.repositoryDetails && (
                <div className="mt-2 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
                  <h4 className="text-sm font-medium text-gray-900 dark:text-gray-200 mb-2">
                    Repository Details
                  </h4>
                  <dl className="space-y-1">
                    <div>
                      <dt className="text-sm text-gray-500 dark:text-gray-400">Full Name</dt>
                      <dd className="text-sm text-gray-900 dark:text-gray-200">
                        {syncStatus.repositoryDetails.name}
                      </dd>
                    </div>
                    <div>
                      <dt className="text-sm text-gray-500 dark:text-gray-400">Default Branch</dt>
                      <dd className="text-sm text-gray-900 dark:text-gray-200">
                        {syncStatus.repositoryDetails.default_branch}
                      </dd>
                    </div>
                    <div>
                      <dt className="text-sm text-gray-500 dark:text-gray-400">Last Synced</dt>
                      <dd className="text-sm text-gray-900 dark:text-gray-200">
                        {syncStatus.lastSynced?.toLocaleString(undefined, {
                          year: 'numeric',
                          month: 'short',
                          day: 'numeric',
                          hour: '2-digit',
                          minute: '2-digit'
                        })}
                      </dd>
                    </div>
                  </dl>
                </div>
              )}
            </div>
          </div>
        );
      case 'failed':
        return (
          <div className="text-red-500">
            <p className="flex items-center gap-2">
              <span>âŒ</span>
              Sync failed
            </p>
            {syncStatus.error && (
              <p className="text-sm mt-1">{syncStatus.error}</p>
            )}
            <button 
              onClick={handleRetrieveRepository}
              className="text-sm underline mt-2"
            >
              Try again
            </button>
          </div>
        );
      default:
        return null;
    }
  };

  // Helper function to check status
  const isStatus = (status: SyncStatusType, checkStatus: SyncStatusType): boolean => {
    return status === checkStatus;
  };

  if (isLoading) {
    return (
      <div className="container mx-auto py-6 min-h-screen bg-white dark:bg-[#262b3d]">
        <div className="flex items-center justify-center">
          <Loader2 className="h-8 w-8 animate-spin text-gray-500" />
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-6 min-h-screen bg-white dark:bg-[#262b3d]">
      <h1 className="text-2xl font-bold mb-6 text-gray-900 dark:text-gray-200">
        Connect to GitHub Repository
      </h1>
      
      <div className="bg-white dark:bg-[#1e2132] border border-gray-200 dark:border-gray-700 rounded-lg shadow p-6 max-w-2xl">
        {!isConnected ? (
          <div className="text-center p-6">
            <p className="text-gray-600 dark:text-gray-400 mb-4">
              Please connect your GitHub account in Settings first
            </p>
            <a
              href="/settings/github"
              className="inline-flex items-center gap-2 px-4 py-2 bg-[#2b2f44] hover:bg-[#363b52] text-gray-200 rounded-lg transition-colors duration-200"
            >
              <Settings className="h-5 w-5" />
              Go to Settings
            </a>
          </div>
        ) : (
          <div className="space-y-6">
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                Select Repository
              </label>
              <div className="relative">
                <button
                  onClick={() => setIsDropdownOpen(!isDropdownOpen)}
                  className="w-full flex items-center justify-between px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
                >
                  <span>{selectedRepo ? selectedRepo.full_name : 'Choose a repository'}</span>
                  <ChevronDown className="h-5 w-5" />
                </button>
                
                {isDropdownOpen && (
                  <div className="absolute z-10 w-full mt-1 bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg">
                    {/* Search input */}
                    <div className="p-2 border-b border-gray-200 dark:border-gray-600">
                      <div className="relative">
                        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                        <input
                          type="text"
                          value={searchQuery}
                          onChange={(e) => setSearchQuery(e.target.value)}
                          placeholder="Search repositories..."
                          className="w-full pl-9 pr-4 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md 
                                   bg-gray-50 dark:bg-gray-800 
                                   text-gray-900 dark:text-gray-100
                                   placeholder-gray-500 dark:placeholder-gray-400
                                   focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400"
                        />
                      </div>
                    </div>

                    {/* Repository list */}
                    <div className="max-h-60 overflow-auto">
                      {filteredRepositories.length === 0 ? (
                        <div className="px-4 py-3 text-sm text-gray-500 dark:text-gray-400 text-center">
                          No repositories found
                        </div>
                      ) : (
                        filteredRepositories.map((repo) => (
                          <button
                            key={repo.id}
                            onClick={() => {
                              setSelectedRepo(repo);
                              setIsDropdownOpen(false);
                              setSearchQuery(''); // Clear search when selecting
                            }}
                            className="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-600 text-gray-900 dark:text-gray-100"
                          >
                            <div className="font-medium">{repo.full_name}</div>
                            {repo.description && (
                              <div className="text-sm text-gray-500 dark:text-gray-400 truncate">
                                {repo.description}
                              </div>
                            )}
                          </button>
                        ))
                      )}
                    </div>

                    {/* Show count when filtering */}
                    {searchQuery && (
                      <div className="px-4 py-2 text-xs text-gray-500 dark:text-gray-400 border-t border-gray-200 dark:border-gray-600">
                        Found {filteredRepositories.length} repositories
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>

            {selectedRepo && (
              <div className="space-y-4">
                <div className="p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
                  <h3 className="text-sm font-medium text-gray-900 dark:text-gray-200 mb-2">
                    Selected Repository Details
                  </h3>
                  <dl className="space-y-2">
                    <div>
                      <dt className="text-xs text-gray-500 dark:text-gray-400">Name</dt>
                      <dd className="text-gray-900 dark:text-gray-200">{selectedRepo.full_name}</dd>
                    </div>
                    <div>
                      <dt className="text-xs text-gray-500 dark:text-gray-400">Default Branch</dt>
                      <dd className="text-gray-900 dark:text-gray-200">{selectedRepo.default_branch}</dd>
                    </div>
                    {selectedRepo.description && (
                      <div>
                        <dt className="text-xs text-gray-500 dark:text-gray-400">Description</dt>
                        <dd className="text-gray-900 dark:text-gray-200">{selectedRepo.description}</dd>
                      </div>
                    )}
                  </dl>
                </div>

                {syncStatus.status === 'idle' ? (
                  <button
                    onClick={handleRetrieveRepository}
                    disabled={isLoading}
                    className={`
                      w-full flex items-center justify-center gap-2 px-4 py-2
                      bg-[#2b2f44] hover:bg-[#363b52] disabled:opacity-50
                      text-gray-200
                      rounded-lg transition-colors duration-200
                    `}
                  >
                    {isLoading ? (
                      <Loader2 className="h-5 w-5 animate-spin" />
                    ) : (
                      <Github className="h-5 w-5" />
                    )}
                    {isLoading ? 'Starting Sync...' : 'Retrieve Repository'}
                  </button>
                ) : (
                  <div className="mt-4">
                    {renderSyncStatus()}
                  </div>
                )}

                {error && (
                  <div className="mt-2 text-red-500 text-sm">
                    {error}
                  </div>
                )}
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}


--- File: ./src/components/Codebase/CodebaseViewer.tsx ---

import { useEffect, useState } from 'react';
import { db } from '../../services/firebase';
import { collection, query, getDocs, doc, getDoc } from 'firebase/firestore';
import { Loader2, FolderIcon, XCircle, Search, FileIcon, FileTextIcon, FileCodeIcon, FileJsonIcon, ImageIcon, FileTypeIcon, PackageIcon, Settings2Icon, DatabaseIcon, LockIcon } from 'lucide-react';
import { useAccount } from '../../context/AccountContext';
import { useNavigate } from 'react-router-dom';
import { Table, TableBody, TableCell, TableContainer, TableHead, TablePagination, TableRow, Paper, TextField, InputAdornment } from '@mui/material';
import { 
  SiPython, 
  SiJavascript, 
  SiTypescript, 
  SiReact, 
  SiVuedotjs,
  SiHtml5,
  SiCss3,
  SiJavascript as SiJava,
  SiPhp,
  SiRuby,
  SiSwift,
  SiKotlin,
  SiGo,
  SiRust,
  SiMarkdown,
  SiDocker,
  SiGit
} from 'react-icons/si';

interface RepositoryFile {
  path: string;
  content?: string;
  type?: 'file' | 'directory';
  [key: string]: any;
}

interface Repository {
  files: RepositoryFile[];
  metadata: {
    name: string;
    description?: string;
    default_branch: string;
    sync_status: string;
    last_synced?: Date;
  };
}

const formatDate = (timestamp: any) => {
  if (!timestamp) return '-';
  // Handle both Firestore Timestamps and regular dates/numbers
  const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
  return date.toLocaleString();
};

const getContentPreview = (content: string | undefined) => {
  if (!content) return '-';
  return content.slice(0, 100) + (content.length > 100 ? '...' : '');
};

const getFileIcon = (filePath: string) => {
  const extension = filePath.split('.').pop()?.toLowerCase() || '';
  const fileName = filePath.toLowerCase();

  // Language-specific icons
  switch (extension) {
    // Python
    case 'py':
      return <SiPython className="h-4 w-4 text-blue-500" />;
    
    // JavaScript
    case 'js':
      return <SiJavascript className="h-4 w-4 text-yellow-400" />;
    
    // TypeScript
    case 'ts':
      return <SiTypescript className="h-4 w-4 text-blue-600" />;
    
    // React
    case 'jsx':
    case 'tsx':
      return <SiReact className="h-4 w-4 text-cyan-400" />;
    
    // Vue
    case 'vue':
      return <SiVuedotjs className="h-4 w-4 text-emerald-400" />;
    
    // HTML
    case 'html':
    case 'htm':
      return <SiHtml5 className="h-4 w-4 text-orange-500" />;
    
    // CSS
    case 'css':
    case 'scss':
    case 'sass':
    case 'less':
      return <SiCss3 className="h-4 w-4 text-blue-500" />;
    
    // Java
    case 'java':
      return <SiJava className="h-4 w-4 text-red-500" />;
    
    // PHP
    case 'php':
      return <SiPhp className="h-4 w-4 text-purple-500" />;
    
    // Ruby
    case 'rb':
      return <SiRuby className="h-4 w-4 text-red-600" />;
    
    // Swift
    case 'swift':
      return <SiSwift className="h-4 w-4 text-orange-500" />;
    
    // Kotlin
    case 'kt':
    case 'kts':
      return <SiKotlin className="h-4 w-4 text-purple-600" />;
    
    // Go
    case 'go':
      return <SiGo className="h-4 w-4 text-cyan-500" />;
    
    // Rust
    case 'rs':
      return <SiRust className="h-4 w-4 text-orange-600" />;
    
    // Markdown
    case 'md':
    case 'mdx':
      return <SiMarkdown className="h-4 w-4 text-gray-500" />;
    
    // JSON
    case 'json':
      return <FileJsonIcon className="h-4 w-4 text-yellow-600" />;
    
    // YAML
    case 'yml':
    case 'yaml':
      return <FileCodeIcon className="h-4 w-4 text-gray-500" />;
  }

  // Special files
  if (fileName === 'dockerfile') {
    return <SiDocker className="h-4 w-4 text-blue-500" />;
  }
  if (fileName === '.gitignore' || fileName.endsWith('.git')) {
    return <SiGit className="h-4 w-4 text-orange-600" />;
  }

  // Directory
  if (!extension || extension === filePath) {
    return <FolderIcon className="h-4 w-4 text-yellow-400" />;
  }

  // Default file icon
  return <FileIcon className="h-4 w-4 text-gray-400" />;
};

// Add this new component for file viewing
const FileViewer = ({ file, onClose }: { file: RepositoryFile; onClose: () => void }) => {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg w-full max-w-4xl max-h-[90vh] flex flex-col">
        <div className="p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
          <div className="flex items-center gap-2">
            {getFileIcon(file.path)}
            <h3 className="text-lg font-medium text-gray-900 dark:text-white">
              {file.path}
            </h3>
          </div>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
          >
            <XCircle className="h-5 w-5" />
          </button>
        </div>
        
        <div className="flex-1 overflow-auto p-4">
          {file.type === 'directory' ? (
            <div className="text-gray-500 dark:text-gray-400">
              This is a directory
            </div>
          ) : (
            <pre className="font-mono text-sm bg-gray-50 dark:bg-gray-900 p-4 rounded-lg overflow-auto">
              <code className="text-gray-900 dark:text-gray-100">
                {file.content || 'No content available'}
              </code>
            </pre>
          )}
        </div>
        
        <div className="p-4 border-t border-gray-200 dark:border-gray-700 text-sm text-gray-500 dark:text-gray-400">
          <div className="flex gap-4">
            <span>Size: {file.size || 'Unknown'}</span>
            <span>Last indexed: {formatDate(file.indexed_at)}</span>
          </div>
        </div>
      </div>
    </div>
  );
};

type SortColumn = 'path' | 'type' | 'size' | 'indexed_at';
type SortDirection = 'asc' | 'desc';

export default function CodebaseViewer() {
  const [loading, setLoading] = useState(true);
  const [files, setFiles] = useState<RepositoryFile[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [selectedFile, setSelectedFile] = useState<RepositoryFile | null>(null);
  const { currentAccount, isLoading: accountLoading } = useAccount();
  const navigate = useNavigate();
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [searchTerm, setSearchTerm] = useState('');
  const [sortColumn, setSortColumn] = useState<SortColumn>('path');
  const [sortDirection, setSortDirection] = useState<SortDirection>('asc');

  useEffect(() => {
    if (accountLoading) return;

    if (!currentAccount?.settings?.githubRepository) {
      setLoading(false);
      setError('No repository selected');
      return;
    }

    const fetchRepository = async () => {
      try {
        setLoading(true);
        setError(null);

        const repoName = currentAccount.settings.githubRepository;
        if (!repoName) {
          setError('No repository selected');
          return;
        }

        // Get the repository document first to check ownership
        const repoRef = doc(db, 'repositories', repoName.replace('/', '_'));
        const repoDoc = await getDoc(repoRef);

        if (!repoDoc.exists()) {
          setError('Repository not found');
          return;
        }

        // Check if this repository belongs to the current account
        const repoData = repoDoc.data();
        if (repoData.accountId && repoData.accountId !== currentAccount.id) {
          setError('You do not have access to this repository');
          return;
        }

        // Fetch files from the repository
        const filesCollectionRef = collection(repoRef, 'files');
        const filesSnapshot = await getDocs(filesCollectionRef);

        if (filesSnapshot.empty) {
          setError('No files found. Please sync the repository first.');
          return;
        }

        const fetchedFiles = filesSnapshot.docs.map(doc => ({
          path: doc.id,
          ...doc.data()
        })) as RepositoryFile[];

        console.log('Files found:', fetchedFiles);
        setFiles(fetchedFiles);

      } catch (err) {
        console.error('Error fetching repository:', err);
        setError(err instanceof Error ? err.message : 'Failed to fetch repository');
      } finally {
        setLoading(false);
      }
    };

    fetchRepository();
  }, [currentAccount, accountLoading]);

  const handleChangePage = (event: unknown, newPage: number) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event: React.ChangeEvent<HTMLInputElement>) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const handleSort = (column: SortColumn) => {
    if (sortColumn === column) {
      // Toggle direction if clicking the same column
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      // Set new column and default to ascending
      setSortColumn(column);
      setSortDirection('asc');
    }
  };

  const getSortedFiles = (files: RepositoryFile[]) => {
    return [...files].sort((a, b) => {
      const multiplier = sortDirection === 'asc' ? 1 : -1;

      switch (sortColumn) {
        case 'path':
          return multiplier * a.path.localeCompare(b.path);
        
        case 'type':
          return multiplier * ((a.type || 'file').localeCompare(b.type || 'file'));
        
        case 'size':
          const sizeA = a.size ? parseInt(a.size.toString()) : 0;
          const sizeB = b.size ? parseInt(b.size.toString()) : 0;
          return multiplier * (sizeA - sizeB);
        
        case 'indexed_at':
          const dateA = a.indexed_at ? new Date(a.indexed_at).getTime() : 0;
          const dateB = b.indexed_at ? new Date(b.indexed_at).getTime() : 0;
          return multiplier * (dateA - dateB);
        
        default:
          return 0;
      }
    });
  };

  const SortIcon = ({ column }: { column: SortColumn }) => {
    if (sortColumn !== column) {
      return (
        <span className="text-gray-400 ml-2">â†•</span>
      );
    }
    return (
      <span className="text-gray-900 dark:text-white ml-2">
        {sortDirection === 'asc' ? 'â†‘' : 'â†“'}
      </span>
    );
  };

  // Get sorted and filtered files
  const sortedAndFilteredFiles = getSortedFiles(
    files.filter((file) => 
      file.path.toLowerCase().includes(searchTerm.toLowerCase())
    )
  );

  const renderSyncStatus = () => {
    if (!currentAccount?.settings?.githubRepository) return null;

    if (error) {
      return (
        <div className="mb-4 p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
          <div className="flex items-center">
            <XCircle className="h-5 w-5 text-red-500 mr-2" />
            <div>
              <p className="text-sm text-red-700 dark:text-red-400">
                {error}
              </p>
              <button
                onClick={() => navigate('/codebase/connect')}
                className="mt-1 text-sm text-red-600 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 underline"
              >
                Try syncing again
              </button>
            </div>
          </div>
        </div>
      );
    }

    return null;
  };

  if (accountLoading || loading) {
    return (
      <div className="flex items-center justify-center h-full">
        <Loader2 className="w-6 h-6 animate-spin" />
      </div>
    );
  }

  if (!currentAccount?.settings?.githubRepository) {
    return (
      <div className="flex flex-col items-center justify-center h-full gap-4">
        <p className="text-gray-500 dark:text-gray-400">
          No repository selected
        </p>
        <button
          onClick={() => navigate('/settings/github')}
          className="text-sm text-blue-500 hover:text-blue-600 dark:text-blue-400 dark:hover:text-blue-300"
        >
          Go to GitHub Settings to select a repository
        </button>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full bg-white dark:bg-gray-900">
      <header className="mb-6 px-6 pt-6">
        <div className="flex justify-between items-center">
          <div>
            <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
              Repository: {currentAccount.settings.githubRepository}
            </h2>
            <p className="text-sm text-gray-500 dark:text-gray-400">Browse repository files</p>
          </div>
          <button
            onClick={() => navigate('/codebase/connect')}
            className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600"
          >
            Sync Repository
          </button>
        </div>
      </header>

      <div className="p-6">
        <div className="mb-6">
          <TextField
            fullWidth
            size="small"
            placeholder="Search files..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="dark:bg-gray-800"
            InputProps={{
              className: 'dark:text-white',
              startAdornment: (
                <InputAdornment position="start">
                  <Search className="w-5 h-5 text-gray-400 dark:text-gray-500" />
                </InputAdornment>
              ),
            }}
          />
        </div>

        {sortedAndFilteredFiles.length > 0 ? (
          <TableContainer 
            component={Paper} 
            className="bg-white dark:bg-gray-800 shadow-sm"
          >
            <Table>
              <TableHead>
                <TableRow className="bg-gray-50 dark:bg-gray-700">
                  <TableCell 
                    className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600 cursor-pointer"
                    onClick={() => handleSort('path')}
                  >
                    <div className="flex items-center">
                      File Path
                      <SortIcon column="path" />
                    </div>
                  </TableCell>
                  <TableCell 
                    className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600 cursor-pointer"
                    onClick={() => handleSort('type')}
                  >
                    <div className="flex items-center">
                      Type
                      <SortIcon column="type" />
                    </div>
                  </TableCell>
                  <TableCell 
                    className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600 cursor-pointer"
                    onClick={() => handleSort('size')}
                  >
                    <div className="flex items-center">
                      Size
                      <SortIcon column="size" />
                    </div>
                  </TableCell>
                  <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">
                    Preview
                  </TableCell>
                  <TableCell 
                    className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600 cursor-pointer"
                    onClick={() => handleSort('indexed_at')}
                  >
                    <div className="flex items-center">
                      Indexed At
                      <SortIcon column="indexed_at" />
                    </div>
                  </TableCell>
                </TableRow>
              </TableHead>
              <TableBody className="dark:bg-gray-800">
                {sortedAndFilteredFiles
                  .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)
                  .map((file) => (
                    <TableRow
                      key={file.path}
                      onClick={() => setSelectedFile(file)}
                      className="cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors duration-150"
                    >
                      <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">
                        <div className="flex items-center gap-2">
                          {getFileIcon(file.path)}
                          <span className="truncate">{file.path}</span>
                        </div>
                      </TableCell>
                      <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">
                        {file.type || 'file'}
                      </TableCell>
                      <TableCell className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600">
                        {file.size || '-'}
                      </TableCell>
                      <TableCell 
                        className="text-gray-900 dark:text-gray-100 border-b dark:border-gray-600 max-w-md"
                      >
                        <div className="truncate font-mono text-sm">
                          {getContentPreview(file.content)}
                        </div>
                      </TableCell>
                      <TableCell className="text-gray-600 dark:text-gray-400 border-b dark:border-gray-600">
                        {formatDate(file.indexed_at)}
                      </TableCell>
                    </TableRow>
                  ))}
              </TableBody>
            </Table>
            <TablePagination
              rowsPerPageOptions={[5, 10, 25]}
              component="div"
              count={sortedAndFilteredFiles.length}
              rowsPerPage={rowsPerPage}
              page={page}
              onPageChange={handleChangePage}
              onRowsPerPageChange={handleChangeRowsPerPage}
              className="text-gray-900 dark:text-gray-100"
              sx={{
                '.MuiTablePagination-select': {
                  color: 'inherit',
                },
                '.MuiTablePagination-selectIcon': {
                  color: 'inherit',
                },
                '.MuiTablePagination-displayedRows': {
                  color: 'inherit',
                },
                '.MuiIconButton-root': {
                  color: 'inherit',
                },
              }}
            />
          </TableContainer>
        ) : (
          <div className="flex flex-col items-center justify-center p-6 text-gray-400">
            <XCircle className="w-5 h-5 mb-2" />
            <p className="text-sm">No files found</p>
          </div>
        )}
      </div>

      {/* Add the FileViewer modal */}
      {selectedFile && (
        <FileViewer
          file={selectedFile}
          onClose={() => setSelectedFile(null)}
        />
      )}
    </div>
  );
}

--- File: ./src/components/Codebase/index.ts ---

export { default as Connect } from './Connect';


--- File: ./src/components/Chat/MessageInput.tsx ---

import React, { useState } from 'react';
import { Send, Smile } from 'lucide-react';
import EmojiPicker from './EmojiPicker';
import { theme, commonStyles, typography, layout, animations } from '../../styles';

interface MessageInputProps {
  message: string;
  setMessage: (message: string) => void;
  handleSendMessage: (e: React.FormEvent) => void;
  className?: string;
}

// Import or define the EmojiData interface
interface EmojiData {
  id: string;
  name: string;
  native: string;
  unified: string;
  keywords: string[];
  shortcodes: string;
  emoticon?: string;
}

export default function MessageInput({ 
  message, 
  setMessage, 
  handleSendMessage,
  className = ''
}: MessageInputProps) {
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);

  const handleEmojiSelect = (emoji: EmojiData) => {
    console.log('MessageInput - handling emoji:', emoji);
    setMessage(message + emoji.native);
    setShowEmojiPicker(false);
  };

  return (
    <div className={className}>
      <div className="relative">
        {/* Emoji Picker */}
        {showEmojiPicker && (
          <div className={`
            absolute bottom-full right-0 mb-2
            ${animations.transition.normal}
          `}>
            <EmojiPicker 
              onEmojiSelect={handleEmojiSelect}
              theme="dark"
            />
          </div>
        )}

        {/* Message Form */}
        <form 
          onSubmit={handleSendMessage}
          className={layout.flex.between}
        >
          <div className={`
            relative flex-1 mr-3
            ${animations.transition.normal}
          `}>
            {/* Emoji Button */}
            <button
              type="button"
              onClick={() => setShowEmojiPicker(!showEmojiPicker)}
              className={`
                ${commonStyles.button.base}
                ${commonStyles.button.secondary}
                !p-2 absolute left-2 top-1/2 -translate-y-1/2
                rounded-full
              `}
            >
              <Smile className={`
                w-5 h-5
                ${showEmojiPicker 
                  ? 'text-blue-500 dark:text-blue-400' 
                  : 'text-gray-400 dark:text-gray-500'
                }
              `} />
            </button>

            {/* Message Input */}
            <input
              type="text"
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              placeholder="Type a message..."
              className={`
                ${commonStyles.input}
                pl-12 pr-4 py-3
                text-base
              `}
            />
          </div>

          {/* Send Button */}
          <button
            type="submit"
            disabled={!message.trim()}
            className={`
              ${commonStyles.button.base}
              ${commonStyles.button.primary}
              !p-3
              disabled:opacity-50 disabled:cursor-not-allowed
              ${animations.transition.normal}
            `}
          >
            <Send className={`
              w-5 h-5
              ${message.trim() 
                ? 'text-white' 
                : 'text-gray-300 dark:text-gray-600'
              }
            `} />
          </button>
        </form>
      </div>
    </div>
  );
}

--- File: ./src/components/Chat/EmojiPicker.tsx ---

import React from 'react';
import data from '@emoji-mart/data';
import Picker from '@emoji-mart/react';
import { theme, commonStyles, typography, layout, animations } from '../../styles';

interface EmojiPickerProps {
  onEmojiSelect: (emoji: any) => void;
  theme?: 'light' | 'dark';
}

// Define the emoji data structure
interface EmojiData {
  id: string;
  name: string;
  native: string;
  unified: string;
  keywords: string[];
  shortcodes: string;
  emoticon?: string;
}

export default function EmojiPicker({ onEmojiSelect, theme = 'light' }: EmojiPickerProps) {
  const customPickerStyles = {
    '--em-rgb-background': theme === 'dark' ? '30, 33, 50' : '255, 255, 255',
    '--em-rgb-input': theme === 'dark' ? '43, 47, 68' : '247, 248, 249',
    '--em-rgb-color': theme === 'dark' ? '243, 244, 246' : '17, 24, 39',
    '--em-color-border': theme === 'dark' ? '#374151' : '#e5e7eb',
  } as React.CSSProperties;

  return (
    <div className={`
      ${animations.transition.normal}
      ${animations.fade.enter}
      rounded-xl overflow-hidden
      shadow-lg
      border border-gray-200 dark:border-gray-700
    `}>
      <Picker
        data={data}
        onEmojiSelect={onEmojiSelect}
        theme={theme}
        previewPosition="none"
        skinTonePosition="none"
        searchPosition="sticky"
        navPosition="bottom"
        perLine={8}
        style={customPickerStyles}
      />
    </div>
  );
}

// Add these styles to your global CSS or theme
const globalStyles = `
  .em-emoji-picker {
    --color-border: var(--em-color-border) !important;
    border: none !important;
    font-family: inherit !important;
  }

  .em-emoji-picker .em-search-container {
    padding: 0.75rem !important;
  }

  .em-emoji-picker input.em-search {
    border-radius: 0.75rem !important;
    padding: 0.75rem 1rem !important;
    font-size: 0.875rem !important;
  }

  .em-emoji-picker .em-category-label {
    font-size: 0.875rem !important;
    font-weight: 500 !important;
    padding: 0.5rem 0.75rem !important;
  }

  .em-emoji-picker .em-emoji-category {
    padding: 0.5rem !important;
  }

  .em-emoji-picker .em-emoji {
    width: 2rem !important;
    height: 2rem !important;
    border-radius: 0.5rem !important;
  }

  .em-emoji-picker .em-emoji:hover {
    background-color: rgba(var(--em-rgb-input), 0.5) !important;
  }

  .em-emoji-picker .em-nav {
    padding: 0.5rem !important;
  }

  .em-emoji-picker .em-nav button {
    border-radius: 0.5rem !important;
    padding: 0.5rem !important;
  }

  .dark .em-emoji-picker {
    --color-border: var(--em-color-border) !important;
  }
`;

--- File: ./src/components/Chat/ChatInterface.tsx ---

import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import { subscribeToMessages, sendMessage, subscribeToUsers } from '../../services/chat';
import { CustomUser } from '../../types/user';
import { Message } from '../../types/message';
import MessageList from './MessageList';
import MessageInput from './MessageInput';
import { theme, commonStyles, typography, layout, animations } from '../../styles';
import { useAccount } from '../../context/AccountContext';

export default function ChatInterface() {
  const { userId } = useParams();
  const { user } = useAuth();
  const { currentAccount } = useAccount();
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [users, setUsers] = useState<{ [key: string]: CustomUser }>({});

  // Create a consistent channel ID for DMs by sorting user IDs
  const getDMChannelId = (user1Id: string, user2Id: string) => {
    const sortedIds = [user1Id, user2Id].sort();
    return `dm_${sortedIds[0]}_${sortedIds[1]}`;
  };

  // Determine the channel ID based on whether it's a DM or general chat
  const channelId = userId && user?.uid 
    ? getDMChannelId(user.uid, userId)
    : 'general';

  console.log('Current channel ID:', channelId); // Debug log

  // Subscribe to messages
  useEffect(() => {
    if (!user || !currentAccount?.id) {
      console.log('No user or account, skipping message subscription');
      return;
    }

    console.log('Setting up message subscription for channel:', channelId);
    setIsLoading(true);
    
    const unsubscribe = subscribeToMessages(channelId, (newMessages) => {
      console.log('Received messages:', newMessages);
      setMessages(newMessages);
      setIsLoading(false);
    });

    return () => {
      console.log('Cleaning up message subscription');
      unsubscribe();
    };
  }, [user, channelId, currentAccount]);

  // Subscribe to users
  useEffect(() => {
    if (!currentAccount?.id) {
      console.log('[ChatInterface] No current account, skipping users subscription');
      setUsers({});
      setIsLoading(false);
      return;
    }

    const memberIds = Object.keys(currentAccount.members);
    console.log('[ChatInterface] Setting up users subscription for members:', memberIds);

    const unsubscribe = subscribeToUsers(
      currentAccount.id,
      memberIds,
      (fetchedUsers) => {
        console.log('[ChatInterface] Received users data:', fetchedUsers);
        setUsers(fetchedUsers);
        setIsLoading(false);
      }
    );

    return () => {
      console.log('[ChatInterface] Cleaning up users subscription');
      unsubscribe();
    };
  }, [currentAccount]);

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!message.trim() || !user || !currentAccount?.id) return;

    try {
      const newMessage = {
        content: message,
        timestamp: Date.now(),
        userId: user.uid,
        channelId: channelId,
        accountId: currentAccount.id
      };
      
      console.log('Sending message:', newMessage);
      await sendMessage(channelId, newMessage);
      setMessage('');
    } catch (error) {
      console.error("Failed to send message:", error);
    }
  };

  // Debug render
  console.log('ChatInterface render:', {
    userId,
    channelId,
    messagesCount: messages.length,
    usersLoaded: Object.keys(users).length,
    isLoading
  });

  // Get the other user's display name
  const otherUser = userId ? users[userId] : null;
  const otherUserName = otherUser?.displayName || otherUser?.email || 'Loading...';
  const subtitle = userId ? (otherUser?.email || 'Loading...') : 'Public channel';

  return (
    <div className="flex flex-col h-full">
      <header className={commonStyles.header.wrapper}>
        <div className={commonStyles.header.container}>
          <div className={commonStyles.header.titleWrapper}>
            <h2 className={commonStyles.header.title}>
              {userId ? `Chat with ${otherUserName}` : 'General Chat'}
            </h2>
            {otherUser?.email && (
              <p className={commonStyles.header.subtitle}>{otherUser.email}</p>
            )}
          </div>
        </div>
      </header>
      
      <div className="flex-1 overflow-y-auto bg-gray-50 dark:bg-gray-900">
        <MessageList 
          messages={messages}
          isLoading={isLoading}
          currentUser={user}
          users={users}
          className="p-4 space-y-4"
        />
      </div>

      <MessageInput 
        message={message}
        setMessage={setMessage}
        handleSendMessage={handleSendMessage}
        className="bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 p-4"
      />
    </div>
  );
}

--- File: ./src/components/Chat/MessageList.tsx ---

import React, { useEffect, useRef, useState } from 'react';
import { Message } from '../../types/message';
import { CustomUser } from '../../types/user';
import { theme, commonStyles, typography, layout, animations } from '../../styles';
import { Loader, User } from 'lucide-react';
import { format } from 'date-fns';

export interface MessageListProps {
  messages: Message[];
  isLoading: boolean;   
  currentUser: CustomUser | null;
  users: { [key: string]: CustomUser };
  className?: string;
}

const UserAvatar = ({ userData, size = "small" }: { 
  userData: { displayName?: string; email?: string; photoURL?: string; }; 
  size?: "small" | "medium" 
}) => {
  const [imageError, setImageError] = useState(false);
  const initials = userData?.displayName 
    ? userData.displayName.split(' ').map(n => n[0]).join('').toUpperCase()
    : userData?.email?.charAt(0).toUpperCase() || '?';

  const sizeClasses = size === "small" ? "w-8 h-8" : "w-10 h-10";

  if (!userData || imageError) {
    return (
      <div className={`${sizeClasses} rounded-full flex items-center justify-center
                    bg-gray-600 text-gray-300`}>
        <span className="text-sm font-medium">{initials}</span>
      </div>
    );
  }

  return (
    <div className={`${sizeClasses} rounded-full flex items-center justify-center overflow-hidden
                  bg-gray-600`}>
      {userData.photoURL ? (
        <img 
          src={userData.photoURL} 
          alt={userData.displayName || userData.email || ''}
          className="w-full h-full object-cover"
          onError={() => setImageError(true)}
        />
      ) : (
        <span className="text-sm font-medium text-gray-300">
          {initials}
        </span>
      )}
    </div>
  );
};

const DateSeparator = ({ date }: { date: Date }) => {
  const formatDate = (date: Date) => {
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    if (date.toDateString() === today.toDateString()) {
      return 'Today';
    } else if (date.toDateString() === yesterday.toDateString()) {
      return 'Yesterday';
    } else {
      return date.toLocaleDateString('en-US', { 
        weekday: 'long',
        month: 'long',
        day: 'numeric'
      });
    }
  };

  return (
    <div className={`
      ${layout.flex.center}
      relative py-4
    `}>
      <div className="absolute left-0 right-0 h-px bg-gray-200 dark:bg-gray-700" />
      <span className={`
        ${typography.small}
        px-4 bg-gray-50 dark:bg-gray-800
        text-gray-500 dark:text-gray-400
        relative z-10
      `}>
        {formatDate(date)}
      </span>
    </div>
  );
};

export default function MessageList({ 
  messages, 
  isLoading, 
  currentUser,
  users,
  className = ''
}: MessageListProps) {
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  console.log('[MessageList] Rendering with:', {
    messageCount: messages.length,
    userCount: Object.keys(users).length,
    users: users, // Log full users object
    currentUser: currentUser?.uid
  });

  if (isLoading) {
    return (
      <div className={`
        ${layout.flex.center}
        h-full flex-col gap-3
      `}>
        <Loader className="w-6 h-6 text-blue-500 animate-spin" />
        <p className={typography.body}>Loading messages...</p>
      </div>
    );
  }

  if (messages.length === 0) {
    return (
      <div className={`
        ${layout.flex.center}
        h-full flex-col gap-2
        text-gray-500 dark:text-gray-400
      `}>
        <p className={typography.body}>No messages yet.</p>
        <p className={typography.small}>Start the conversation!</p>
      </div>
    );
  }

  // Group messages by date and then by user
  const groupedMessages = messages.reduce((groups: { [key: string]: Message[][] }, message) => {
    const date = new Date(message.timestamp).toDateString();
    
    if (!groups[date]) {
      groups[date] = [];
    }

    const dateGroups = groups[date];
    const lastGroup = dateGroups[dateGroups.length - 1];
    const lastMessage = lastGroup?.[lastGroup.length - 1];
    
    const shouldStartNewGroup = !lastMessage || 
      lastMessage.userId !== message.userId ||
      message.timestamp - lastMessage.timestamp > 5 * 60 * 1000; // 5 minutes gap

    if (shouldStartNewGroup) {
      dateGroups.push([message]);
    } else {
      lastGroup.push(message);
    }
    
    return groups;
  }, {});

  return (
    <div className="flex-1 overflow-y-auto">
      <div className="space-y-2">
        {Object.entries(groupedMessages).map(([dateStr, dateGroups]) => (
          <div key={dateStr}>
            <DateSeparator date={new Date(dateStr)} />
            
            <div className="space-y-6 px-4">
              {dateGroups.map((group, groupIndex) => {
                const firstMessage = group[0];
                const messageUser = users[firstMessage.userId];
                console.log('[MessageList] Message user data:', {
                  messageUserId: firstMessage.userId,
                  foundUser: messageUser,
                  displayName: messageUser?.displayName
                });
                const senderName = messageUser?.displayName || messageUser?.email || 'Unknown User';

                return (
                  <div key={groupIndex} className="flex items-start gap-3 group">
                    {/* User Avatar */}
                    <div className="flex-shrink-0 mt-1">
                      {messageUser ? (
                        <UserAvatar 
                          userData={messageUser} 
                          size="medium"
                        />
                      ) : (
                        <div className={`
                          ${layout.flex.center}
                          w-10 h-10 rounded-md
                          bg-gray-100 dark:bg-gray-700
                        `}>
                          <User className="w-5 h-5 text-gray-500 dark:text-gray-400" />
                        </div>
                      )}
                    </div>

                    {/* Messages Content */}
                    <div className="flex-1 min-w-0">
                      {/* Sender Info */}
                      <div className={`${layout.flex.start} gap-2`}>
                        <span className={`
                          ${typography.body}
                          font-medium
                          text-gray-900 dark:text-gray-100
                        `}>
                          {senderName}
                        </span>
                        <span className={`
                          ${typography.small}
                          text-gray-500 dark:text-gray-400
                        `}>
                          {new Date(firstMessage.timestamp).toLocaleTimeString([], {
                            hour: '2-digit',
                            minute: '2-digit'
                          })}
                        </span>
                      </div>

                      {/* Messages */}
                      <div className="space-y-1 mt-1">
                        {group.map((message) => (
                          <div 
                            key={message.id}
                            className={`
                              ${typography.body}
                              text-gray-900 dark:text-gray-100
                              hover:bg-gray-50 dark:hover:bg-gray-750
                              -mx-2 px-2 py-1 rounded
                              ${animations.transition.normal}
                            `}
                          >
                            {message.content}
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        ))}
        <div ref={messagesEndRef} />
      </div>
    </div>
  );
}

--- File: ./src/components/ui/dropdown-menu.tsx ---

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className="z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2"
    {...props}
  />
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className="relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50"
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

export { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem }


--- File: ./src/components/ui/button.tsx ---

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "underline-offset-4 hover:underline text-primary",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 px-3 rounded-md",
        lg: "h-11 px-8 rounded-md",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, ...props }, ref) => {
    return (
      <button
        className={buttonVariants({ variant, size, className })}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }


--- File: ./src/components/ui/command.tsx ---

import * as React from "react"
import { Command as CommandPrimitive } from "cmdk"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className="flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground"
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Input
    ref={ref}
    className="flex h-11 w-full rounded-md bg-transparent py-3 px-4 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50"
    {...props}
  />
))
CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className="max-h-[300px] overflow-y-auto overflow-x-hidden"
    {...props}
  />
))
CommandList.displayName = CommandPrimitive.List.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className="relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none aria-selected:bg-accent aria-selected:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50"
    {...props}
  />
))
CommandItem.displayName = CommandPrimitive.Item.displayName

export { Command, CommandInput, CommandList, CommandItem }


--- File: ./src/components/ui/input.tsx ---

import * as React from "react"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={
          `flex h-10 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm text-gray-900 placeholder:text-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50 ${
            className || ''
          }`
        }
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }


--- File: ./src/components/ui/scroll-area.tsx ---

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className="relative overflow-hidden"
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollAreaPrimitive.Scrollbar
      orientation="vertical"
      className="flex touch-none select-none transition-colors"
    >
      <ScrollAreaPrimitive.Thumb className="relative flex-1 rounded-full bg-border" />
    </ScrollAreaPrimitive.Scrollbar>
    <ScrollAreaPrimitive.Scrollbar
      orientation="horizontal"
      className="flex touch-none select-none transition-colors"
    >
      <ScrollAreaPrimitive.Thumb className="relative flex-1 rounded-full bg-border" />
    </ScrollAreaPrimitive.Scrollbar>
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

export { ScrollArea }


--- File: ./src/components/ui/popover.tsx ---

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className="z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none animate-in data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2"
    {...props}
  />
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }


--- File: ./src/components/ui/dialog.tsx ---

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPrimitive.Portal>
    <DialogPrimitive.Overlay className="fixed inset-0 z-50 bg-background/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0" />
    <DialogPrimitive.Content
      ref={ref}
      className="fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg"
      {...props}
    >
      {children}
    </DialogPrimitive.Content>
  </DialogPrimitive.Portal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div className="flex flex-col space-y-1.5 text-center sm:text-left" {...props} />
)
DialogHeader.displayName = "DialogHeader"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className="text-lg font-semibold leading-none tracking-tight"
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

export { Dialog, DialogTrigger, DialogContent, DialogHeader, DialogTitle }


--- File: ./src/components/ui/textarea.tsx ---

import * as React from "react"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className="flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }


--- File: ./src/components/ui/tooltip.tsx ---

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className="z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2"
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }


--- File: ./src/components/ui/avatar.tsx ---

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"
import type { 
  AvatarProps,
  AvatarImageProps,
  AvatarFallbackProps
} from "@radix-ui/react-avatar"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className="relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full"
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className="aspect-square h-full w-full"
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className="flex h-full w-full items-center justify-center rounded-full bg-muted"
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }


--- File: ./src/components/Navigation/Sidebar.tsx ---

import React, { useEffect, useState } from 'react'
import { Link, NavLink, useLocation } from 'react-router-dom'
import { Hash, Plus, Sun, Moon, ListTodo, Kanban, MessageSquare, LayoutGrid, LogOut, User, Github, Settings, FolderOpen } from "lucide-react"
import { ScrollArea } from "../ui/scroll-area"
import { Button } from "../ui/button"
import { CustomUser } from '../../types/user'
import { commonStyles } from '../../styles/theme'
import { animations } from '../../styles/animations'
import { typography } from '../../styles/theme'
import { subscribeToUsers } from '../../services/chat'
import { useAccount } from '../../context/AccountContext'
import { useAuth } from '../../context/AuthContext'
import { collection, query, where, onSnapshot } from 'firebase/firestore'
import { db } from '../../config/firebase'

interface SidebarProps {
  user: CustomUser | null;
  channels: string[];
  users: { [key: string]: CustomUser };
  currentChannel: string;
  isDarkMode: boolean;
  isMobileMenuOpen: boolean;
  setCurrentChannel: (channel: string) => void;
  setIsMobileMenuOpen: (isOpen: boolean) => void;
  setIsDirectMessageModalOpen: (isOpen: boolean) => void;
  setIsCreateChannelModalOpen: (isOpen: boolean) => void;
  toggleDarkMode: () => void;
  handleLogout: () => void;
  handleStartDirectMessage: (userId: string) => void;
}

// Add UserAvatar component
const UserAvatar = ({ userData, size = "small" }: { 
  userData: { displayName?: string; email?: string; photoURL?: string; }; 
  size?: "small" | "medium" 
}) => {
  const [imageError, setImageError] = useState(false);
  const initials = userData?.displayName 
    ? userData.displayName.split(' ').map(n => n[0]).join('').toUpperCase()
    : userData?.email?.charAt(0).toUpperCase() || '?';

  const sizeClasses = size === "small" ? "w-5 h-5" : "w-8 h-8";

  if (!userData || imageError) {
    return (
      <div className={`${sizeClasses} rounded-full flex items-center justify-center
                    bg-gray-600 text-gray-300`}>
        <span className="text-sm font-medium">{initials}</span>
      </div>
    );
  }

  return (
    <div className={`${sizeClasses} rounded-full flex items-center justify-center overflow-hidden
                  bg-gray-600`}>
      {userData.photoURL ? (
        <img 
          src={userData.photoURL} 
          alt={userData.displayName || userData.email || ''}
          className="w-full h-full object-cover"
          onError={() => setImageError(true)}
        />
      ) : (
        <span className="text-sm font-medium text-gray-300">
          {initials}
        </span>
      )}
    </div>
  );
};

export function Sidebar({
  user,
  channels,
  users,
  currentChannel,
  isDarkMode,
  isMobileMenuOpen,
  setCurrentChannel,
  setIsMobileMenuOpen,
  setIsDirectMessageModalOpen,
  setIsCreateChannelModalOpen,
  toggleDarkMode,
  handleLogout,
  handleStartDirectMessage,
}: SidebarProps) {
  const location = useLocation();
  const { currentAccount } = useAccount();
  const { user: authUser } = useAuth();
  const [accountUsers, setAccountUsers] = useState<{ [key: string]: CustomUser }>({});
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (!currentAccount?.id) {
      console.log('[Sidebar] No current account, skipping users subscription');
      setAccountUsers({});
      setIsLoading(false);
      return;
    }

    const memberIds = Object.keys(currentAccount.members);
    console.log('[Sidebar] Setting up users subscription for members:', memberIds);

    const unsubscribe = subscribeToUsers(
      currentAccount.id,
      memberIds,
      (fetchedUsers) => {
        console.log('[Sidebar] Received users:', fetchedUsers);
        setAccountUsers(fetchedUsers);
        setIsLoading(false);
      }
    );

    return () => {
      console.log('[Sidebar] Cleaning up users subscription');
      unsubscribe();
    };
  }, [currentAccount]);

  // Debug log to check users data
  console.log('Users in Sidebar:', users);

  return (
    <div className={commonStyles.layout.sidebar}>
      <div className="p-4 flex justify-between items-center">
        <h1 className={typography.brand}>QEEK</h1>
        <button
          onClick={toggleDarkMode}
          className="p-2 rounded-lg text-gray-300 hover:bg-[#313a55] transition-colors duration-200"
        >
          {isDarkMode ? (
            <Sun className="w-5 h-5" />
          ) : (
            <Moon className="w-5 h-5" />
          )}
        </button>
      </div>

      <nav className="flex-1 p-4 space-y-8">
        {/* Tickets Section */}
        <div>
          <h2 className={typography.sidebarHeader}>Tickets</h2>
          <ul className="space-y-1">
            <li>
              <NavLink
                to="/tickets/backlog"
                className={({ isActive }) =>
                  `flex items-center p-2 rounded-lg ${
                    isActive ? 'bg-gray-700 text-white' : 'text-gray-300 hover:bg-gray-700'
                  }`
                }
              >
                <ListTodo className="h-5 w-5 mr-2" />
                Backlog
              </NavLink>
            </li>
            <li>
              <NavLink
                to="/tickets/board"
                className={({ isActive }) =>
                  `flex items-center p-2 rounded-lg ${
                    isActive ? 'bg-gray-700 text-white' : 'text-gray-300 hover:bg-gray-700'
                  }`
                }
              >
                <LayoutGrid className="h-5 w-5 mr-2" />
                Board
              </NavLink>
            </li>
            <li>
              <NavLink
                to="/tickets/all"
                className={({ isActive }) =>
                  `flex items-center p-2 rounded-lg ${
                    isActive ? 'bg-gray-700 text-white' : 'text-gray-300 hover:bg-gray-700'
                  }`
                }
              >
                <ListTodo className="h-5 w-5 mr-2" />
                All
              </NavLink>
            </li>
          </ul>
        </div>

        {/* Codebase Section */}
        <div>
          <h2 className={typography.sidebarHeader}>Codebase</h2>
          <ul className="space-y-1">
            <li>
              <NavLink
                to="/codebase/connect"
                className={({ isActive }) =>
                  `${commonStyles.sidebar.nav.item} ${
                    isActive ? commonStyles.sidebar.nav.active : commonStyles.sidebar.nav.inactive
                  }`
                }
              >
                <Github className="h-5 w-5 mr-2" />
                Connect
              </NavLink>
            </li>
            <li>
              <NavLink
                to="/codebase/files"
                className={({ isActive }) =>
                  `${commonStyles.sidebar.nav.item} ${
                    isActive ? commonStyles.sidebar.nav.active : commonStyles.sidebar.nav.inactive
                  }`
                }
              >
                <FolderOpen className="h-5 w-5 mr-2" />
                View Files
              </NavLink>
            </li>
          </ul>
        </div>

        {/* Direct Messages Section */}
        <div>
          <div className="flex justify-between items-center mb-2">
            <h2 className={typography.sidebarHeader}>Direct Messages</h2>
            <button
              onClick={() => setIsDirectMessageModalOpen(true)}
              className="p-1 hover:bg-gray-700 rounded text-gray-300"
            >
              <Plus className="h-4 w-4" />
            </button>
          </div>
          {isLoading ? (
            <div className="text-sm text-gray-400 p-2">Loading users...</div>
          ) : Object.keys(accountUsers).length > 0 ? (
            <ScrollArea className="h-[200px]">
              <ul className="space-y-1">
                {Object.entries(accountUsers).map(([userId, userData]) => {
                  const isCurrentUser = userId === authUser?.uid;
                  const userDataToShow = isCurrentUser 
                    ? { 
                        displayName: userData.displayName,
                        email: userData.email,
                        photoURL: authUser?.photoURL
                      }
                    : userData;
                  
                  return (
                    <li key={userId}>
                      <button
                        onClick={() => handleStartDirectMessage(userId)}
                        className={`
                          flex items-center w-full p-2 rounded-lg text-left
                          ${location.pathname === `/chat/dm/${userId}` 
                            ? 'bg-gray-700 text-white' 
                            : 'text-gray-300 hover:bg-gray-700'
                          }
                        `}
                      >
                        <div className="mr-2">
                          <UserAvatar userData={userDataToShow} size="small" />
                        </div>
                        <span className="truncate">
                          {userData.displayName || userData.email || 'Unknown User'}
                          {isCurrentUser && ' (You)'}
                        </span>
                      </button>
                    </li>
                  );
                })}
              </ul>
            </ScrollArea>
          ) : (
            <div className="text-sm text-gray-400 p-2">
              No users in this account
            </div>
          )}
        </div>

        {/* Channels Section */}
        <div>
          <div className="flex justify-between items-center mb-2">
            <h2 className={typography.sidebarHeader}>Channels</h2>
            <button
              onClick={() => setIsCreateChannelModalOpen(true)}
              className="p-1 hover:bg-gray-700 rounded"
            >
              <Plus className="h-4 w-4" />
            </button>
          </div>
          <ul className="space-y-1">
            {channels.map((channel) => (
              <li key={channel}>
                <button
                  onClick={() => {
                    setCurrentChannel(channel);
                    // Navigate to general chat
                    window.location.href = '/chat';
                  }}
                  className={`flex items-center p-2 rounded-lg w-full text-left ${
                    location.pathname === '/chat' && currentChannel === channel
                      ? 'bg-gray-700 text-white'
                      : 'text-gray-300 hover:bg-gray-700'
                  }`}
                >
                  <Hash className="h-5 w-5 mr-2" />
                  {channel}
                </button>
              </li>
            ))}
          </ul>
        </div>
      </nav>

      {/* Footer with Settings and Sign Out */}
      <div className="border-t border-gray-700 p-4 space-y-2">
        <NavLink
          to="/settings/github"
          className="flex items-center w-full p-2 rounded-lg text-gray-300 hover:bg-[#313a55] transition-colors duration-200 gap-2"
        >
          <Settings className="w-5 h-5" />
          <span>Settings</span>
        </NavLink>

        <button
          onClick={handleLogout}
          className="flex items-center w-full p-2 rounded-lg text-gray-300 hover:bg-[#313a55] transition-colors duration-200 gap-2"
        >
          <LogOut className="w-5 h-5" />
          <span>Sign Out</span>
        </button>
      </div>
    </div>
  )
}


--- File: ./src/services/ticketService.ts ---

import { collection, addDoc, updateDoc, deleteDoc, doc, getDoc } from 'firebase/firestore';
import { db } from './firebase';
import { Ticket } from '../types/ticket';
import { getAuth } from 'firebase/auth';
import { database } from '../config/firebase';
import { ref, onValue, push, set, off, get } from 'firebase/database';

export const ticketService = {
  async createTicket(ticket: Omit<Ticket, 'id'>) {
    try {
      if (!db) {
        throw new Error('Firestore is not initialized');
      }

      console.log('Creating ticket with data:', ticket);
      
      // Verify user is authenticated
      const auth = getAuth();
      if (!auth.currentUser) {
        throw new Error('User is not authenticated');
      }

      const ticketsRef = collection(db, 'tickets');
      const docRef = await addDoc(ticketsRef, {
        ...ticket,
        createdBy: auth.currentUser.uid,
        createdAt: Date.now(),
        updatedAt: Date.now()
      });

      console.log('Ticket created successfully with ID:', docRef.id);
      return docRef;
    } catch (error) {
      console.error('Error creating ticket:', error);
      if (error instanceof Error) {
        throw new Error(`Failed to create ticket: ${error.message}`);
      }
      throw error;
    }
  },

  async updateTicket(id: string, ticket: Partial<Ticket>) {
    const ticketRef = doc(db, 'tickets', id);
    await updateDoc(ticketRef, {
      ...ticket,
      updatedAt: Date.now()
    });
  },

  async deleteTicket(id: string) {
    const ticketRef = doc(db, 'tickets', id);
    await deleteDoc(ticketRef);
  },

  async getTicket(id: string) {
    const ticketRef = doc(db, 'tickets', id);
    const ticketSnap = await getDoc(ticketRef);
    if (ticketSnap.exists()) {
      return { id: ticketSnap.id, ...ticketSnap.data() } as Ticket;
    }
    return null;
  }
};

export const fetchTickets = async (): Promise<Ticket[]> => {
  const ticketsRef = ref(database, 'tickets');
  const snapshot = await get(ticketsRef);
  const tickets: Ticket[] = [];
  
  if (snapshot.exists()) {
    snapshot.forEach((childSnapshot) => {
      tickets.push({
        id: childSnapshot.key!,
        ...childSnapshot.val()
      });
    });
  }
  
  return tickets;
};

export const subscribeToTickets = (callback: (tickets: Ticket[]) => void) => {
  console.log('Setting up tickets subscription');
  
  // Try both potential paths
  const ticketsRef = ref(database, 'tickets');
  const channelsTicketsRef = ref(database, 'channels/tickets');
  
  // Debug: Check both paths
  get(ticketsRef).then(snapshot => {
    console.log('Checking /tickets path:', snapshot.exists(), snapshot.val());
  });
  
  get(channelsTicketsRef).then(snapshot => {
    console.log('Checking /channels/tickets path:', snapshot.exists(), snapshot.val());
  });
  
  // Subscribe to the original tickets path
  const unsubscribe = onValue(ticketsRef, (snapshot) => {
    const tickets: Ticket[] = [];
    if (snapshot.exists()) {
      snapshot.forEach((childSnapshot) => {
        const ticket = childSnapshot.val();
        tickets.push({
          id: childSnapshot.key!,
          ...ticket
        });
      });
      console.log('Fetched tickets:', tickets);
    } else {
      console.log('No tickets found in database at /tickets');
    }
    callback(tickets);
  });

  return () => {
    console.log('Unsubscribing from tickets');
    off(ticketsRef);
    unsubscribe();
  };
};

export const createTicket = async (ticket: Omit<Ticket, 'id'>): Promise<string> => {
  console.log('Creating ticket:', ticket);
  const ticketsRef = ref(database, 'tickets');
  const newTicketRef = push(ticketsRef);
  await set(newTicketRef, ticket);
  return newTicketRef.key!;
};

export const updateTicket = async (ticketId: string, updates: Partial<Ticket>): Promise<void> => {
  console.log('Updating ticket:', ticketId, updates);
  const ticketRef = ref(database, `channels/tickets/${ticketId}`);
  await set(ticketRef, updates);
};

export const deleteTicket = async (ticketId: string): Promise<void> => {
  console.log('Deleting ticket:', ticketId);
  const ticketRef = ref(database, `channels/tickets/${ticketId}`);
  await set(ticketRef, null);
};

export const getTicket = async (ticketId: string): Promise<Ticket | null> => {
  console.log('Fetching ticket:', ticketId);
  const ticketRef = ref(database, `channels/tickets/${ticketId}`);
  const snapshot = await get(ticketRef);
  
  if (snapshot.exists()) {
    return {
      id: snapshot.key!,
      ...snapshot.val()
    };
  }
  
  return null;
};

--- File: ./src/services/firebase.ts ---

// Remove Firebase initialization from here
// Just re-export what you need
export { db, auth, functions, app, database } from '../config/firebase';


--- File: ./src/services/chat.ts ---

import { 
  collection, 
  doc,
  addDoc,
  getDocs,
  onSnapshot,
  orderBy,
  query as firestoreQuery,
  serverTimestamp,
  where,
  updateDoc,
  deleteDoc
} from 'firebase/firestore';

import { db, auth, functions } from '../config/firebase';
import { Message } from '../types/message';
import { CustomUser } from '../types/user';

// Subscribe to account users
export const subscribeToUsers = (
  accountId: string, 
  memberIds: string[],
  callback: (users: { [key: string]: CustomUser }) => void
) => {
  if (!accountId || !memberIds.length) {
    console.error('[Chat Service] Cannot subscribe to users: missing accountId or memberIds');
    return () => {};
  }

  console.log('[Chat Service] Starting users subscription for account:', accountId, 'members:', memberIds);
  
  const usersRef = collection(db, 'users');
  const q = firestoreQuery(
    usersRef,
    where('uid', 'in', memberIds)
  );
  
  return onSnapshot(q, 
    (snapshot) => {
      const users: { [key: string]: CustomUser } = {};
      snapshot.forEach((doc) => {
        const userData = doc.data() as CustomUser;
        users[doc.id] = {
          ...userData,
          uid: doc.id,
          displayName: userData.displayName || userData.email || 'Unknown User',
        };
      });

      console.log('[Chat Service] Snapshot received with users:', users);
      callback(users);
    }, 
    (error) => {
      console.error('[Chat Service] Error in users subscription:', error);
      callback({});
    }
  );
};

// Subscribe to channel messages
export const subscribeToMessages = (channelId: string, callback: (messages: Message[]) => void) => {
  const messagesRef = collection(db, 'messages');
  const q = firestoreQuery(
    messagesRef,
    where('channelId', '==', channelId),
    orderBy('timestamp', 'asc')
  );

  return onSnapshot(q, (snapshot) => {
    const messages = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    })) as Message[];
    callback(messages);
  });
};

// Send a new message
export const sendMessage = async (channelId: string, message: Message) => {
  const messagesRef = collection(db, 'messages');
  await addDoc(messagesRef, message);
};

// Update a message
export const updateMessage = async (messageId: string, updates: Partial<Message>) => {
  try {
    const messageRef = doc(db, 'messages', messageId);
    await updateDoc(messageRef, updates);
  } catch (error) {
    console.error("Error updating message:", error);
    throw error;
  }
};

// Delete a message
export const deleteMessage = async (messageId: string) => {
  try {
    const messageRef = doc(db, 'messages', messageId);
    await deleteDoc(messageRef);
  } catch (error) {
    console.error("Error deleting message:", error);
    throw error;
  }
};


--- File: ./src/services/auth.ts ---

import { auth, database } from './firebase';
import { createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "firebase/auth";
import { ref, set } from "firebase/database";
import { CustomUser } from '../types/user';

export const registerUser = async (email: string, password: string) => {
  try {
    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
    const user = userCredential.user as CustomUser;
    user.companyId = 'default';
    await saveUserToDatabase(user);
    return user;
  } catch (error) {
    console.error("Error registering user:", error);
    throw error;
  }
};

export const loginUser = async (email: string, password: string) => {
  try {
    const userCredential = await signInWithEmailAndPassword(auth, email, password);
    const user = userCredential.user as CustomUser;
    user.companyId = 'default'; // You might want to fetch this from the database instead
    await saveUserToDatabase(user);
    return user;
  } catch (error) {
    console.error("Error logging in user:", error);
    throw error;
  }
};

export const logoutUser = async () => {
  try {
    await signOut(auth);
  } catch (error) {
    console.error("Error logging out user:", error);
    throw error;
  }
};

const saveUserToDatabase = async (user: CustomUser) => {
  try {
    const userRef = ref(database, `users/${user.uid}`);
    await set(userRef, {
      displayName: user.displayName || 'Anonymous',
      email: user.email,
      photoURL: user.photoURL || '/placeholder.svg?height=40&width=40',
      companyId: user.companyId || 'default'
    });
    console.log("User saved to database successfully");
  } catch (error) {
    console.error("Error saving user to database:", error);
    throw error;
  }
};

export const createUserRecord = async (user: any, companyId: string) => {
  if (user) {
    const userRef = ref(database, `users/${user.uid}`);
    await set(userRef, {
      email: user.email,
      companyId: companyId,
      // Add any other relevant user data here
    });
  }
};

export const signUp = async (email: string, password: string, companyId: string) => {
  const userCredential = await createUserWithEmailAndPassword(auth, email, password);
  await createUserRecord(userCredential.user, companyId);
};

export const login = async (email: string, password: string, companyId: string) => {
  const userCredential = await signInWithEmailAndPassword(auth, email, password);
  await createUserRecord(userCredential.user, companyId);
};


--- File: ./src/services/github.ts ---

import { db } from './firebase';
import { doc, setDoc, getDoc, deleteDoc, serverTimestamp } from 'firebase/firestore';
import { useAuth } from '../context/AuthContext';

export interface GitHubRepo {
  id: number;
  name: string;
  full_name: string;
  private: boolean;
  description: string | null;
  default_branch: string;
}

export class GitHubService {
  private token: string | null = null;

  async setToken(userId: string, token: string) {
    this.token = token;
    // Store in Firestore
    await setDoc(doc(db, 'users', userId, 'settings', 'github'), {
      token: token,
      updatedAt: new Date().toISOString()
    });
  }

  async getToken(userId: string) {
    if (!this.token) {
      const docRef = doc(db, 'users', userId, 'settings', 'github');
      const docSnap = await getDoc(docRef);
      if (docSnap.exists()) {
        this.token = docSnap.data().token;
      }
    }
    return this.token;
  }

  async clearToken(userId: string) {
    this.token = null;
    await deleteDoc(doc(db, 'users', userId, 'settings', 'github'));
  }

  async validateToken(token: string): Promise<boolean> {
    try {
      const response = await fetch('https://api.github.com/user', {
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });
      return response.ok;
    } catch (error) {
      console.error('Error validating token:', error);
      return false;
    }
  }

  async fetchUserRepositories(userId: string): Promise<GitHubRepo[]> {
    const token = await this.getToken(userId);
    if (!token) throw new Error('GitHub token not found');

    try {
      const response = await fetch('https://api.github.com/user/repos?sort=updated', {
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });

      if (!response.ok) throw new Error('Failed to fetch repositories');

      const repos = await response.json();
      return repos.map((repo: any): GitHubRepo => ({
        id: repo.id,
        name: repo.name,
        full_name: repo.full_name,
        private: repo.private,
        description: repo.description,
        default_branch: repo.default_branch
      }));
    } catch (error) {
      console.error('Error fetching repositories:', error);
      throw error;
    }
  }

  async setSelectedRepository(userId: string, repoFullName: string) {
    await setDoc(doc(db, 'users', userId, 'settings', 'github'), {
      selectedRepository: repoFullName,
      updatedAt: new Date().toISOString()
    }, { merge: true });
  }

  async getSelectedRepository(userId: string) {
    const docRef = doc(db, 'users', userId, 'settings', 'github');
    const docSnap = await getDoc(docRef);
    if (docSnap.exists()) {
      return docSnap.data().selectedRepository;
    }
    return null;
  }
}

export const githubService = new GitHubService();

export const syncRepository = async (accountId: string, repoName: string) => {
  try {
    const repoRef = doc(db, 'repositories', repoName.replace('/', '_'));
    
    // Update or create the repository document with accountId
    await setDoc(repoRef, {
      name: repoName,
      accountId: accountId,
      sync_status: 'syncing',
      last_synced: serverTimestamp()
    }, { merge: true });

    // ... rest of sync logic ...

  } catch (error) {
    console.error('Error syncing repository:', error);
    throw error;
  }
};


--- File: ./src/services/api.ts ---

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001';

export const syncRepository = async (repositoryName: string, userId: string) => {
  const response = await fetch(`${API_BASE_URL}/api/repository/sync`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ repositoryName, userId }),
  });

  if (!response.ok) {
    throw new Error('Failed to start repository sync');
  }

  return response.json();
};


--- File: ./src/services/email.ts ---

import { getFunctions, httpsCallable } from 'firebase/functions';
import { functions } from '../config/firebase';  // Import from your config

interface InvitationEmailData {
  email: string;
  accountName: string;
  role: 'admin' | 'member';
  invitationId: string;
}

export const sendEmailInvitation = async (data: InvitationEmailData) => {
  try {
    // Use the functions instance from your config
    const sendInvitation = httpsCallable(functions, 'sendInvitation');
    
    console.log('Attempting to send invitation:', {
      email: data.email,
      accountName: data.accountName,
      role: data.role,
      invitationId: data.invitationId
    });
    
    const result = await sendInvitation(data);
    return result.data;
  } catch (error: any) {
    console.error('Detailed error:', {
      code: error.code,
      message: error.message,
      details: error.details
    });
    throw error;
  }
};

--- File: ./src/context/AccountContext.tsx ---

import React, { createContext, useContext, useState, useEffect } from 'react';
import { useAuth } from './AuthContext';
import { db } from '../services/firebase';
import { doc, getDoc, setDoc, onSnapshot, collection, query, where } from 'firebase/firestore';
import type { Account } from '../types/account';

interface AccountContextType {
  currentAccount: Account | null;
  isLoading: boolean;
  error: string | null;
  updateAccountSettings: (settings: Partial<Account['settings']>) => Promise<void>;
}

const AccountContext = createContext<AccountContextType | undefined>(undefined);

export function AccountProvider({ children }: { children: React.ReactNode }) {
  const { user } = useAuth();
  const [currentAccount, setCurrentAccount] = useState<Account | null>(null);
  const [accounts, setAccounts] = useState<Account[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!user) {
      console.log('[AccountContext] No user, clearing accounts');
      setAccounts([]);
      setCurrentAccount(null);
      setIsLoading(false);
      return;
    }

    console.log('[AccountContext] Fetching accounts for user:', user.uid);
    
    const accountsRef = collection(db, 'accounts');
    const q = query(
      accountsRef,
      where(`members.${user.uid}`, '!=', null)
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const userAccounts = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as Account[];

      console.log('[AccountContext] Found accounts:', userAccounts);
      setAccounts(userAccounts);
      
      if (!currentAccount && userAccounts.length > 0) {
        console.log('[AccountContext] Setting current account:', userAccounts[0]);
        setCurrentAccount(userAccounts[0]);
      }
      
      setIsLoading(false);
    });

    return () => unsubscribe();
  }, [user]);

  const updateAccountSettings = async (settings: Partial<Account['settings']>) => {
    if (!currentAccount || !user?.uid) return;

    try {
      const updatedSettings = {
        ...currentAccount.settings,
        ...settings
      };

      await setDoc(doc(db, 'accounts', currentAccount.id), {
        settings: updatedSettings,
        updatedAt: new Date().toISOString()
      }, { merge: true });

    } catch (err) {
      console.error('Error updating account settings:', err);
      throw err;
    }
  };

  return (
    <AccountContext.Provider value={{
      currentAccount,
      isLoading,
      error,
      updateAccountSettings
    }}>
      {children}
    </AccountContext.Provider>
  );
}

export function useAccount() {
  const context = useContext(AccountContext);
  if (context === undefined) {
    throw new Error('useAccount must be used within an AccountProvider');
  }
  return context;
}

--- File: ./src/context/AuthContext.tsx ---

import React, { createContext, useContext, useEffect, useState } from 'react';
import { 
  User, 
  UserCredential, 
  onAuthStateChanged, 
  signInWithPopup, 
  GoogleAuthProvider,
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  signOut,
  updateProfile
} from 'firebase/auth';
import { doc, setDoc } from 'firebase/firestore';
import { ref, set } from 'firebase/database';
import { auth, db, database } from '../services/firebase';
import { registerUser, loginUser, logoutUser } from '../services/auth';
import { CustomUser } from '../types/user';

const googleProvider = new GoogleAuthProvider();

interface AuthContextProps {
  user: CustomUser | null;
  setUser: React.Dispatch<React.SetStateAction<CustomUser | null>>;
  login: (email: string, password: string) => Promise<UserCredential>;
  register: (email: string, password: string) => Promise<UserCredential>;
  logout: () => Promise<void>;
  googleSignIn: () => Promise<UserCredential>;
  isDarkMode: boolean;
  toggleDarkMode: () => void;
}

const AuthContext = createContext<AuthContextProps | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<CustomUser | null>(null);
  const [isDarkMode, setIsDarkMode] = useState(() => {
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme) {
      return savedTheme === 'dark';
    }
    return window.matchMedia('(prefers-color-scheme: dark)').matches;
  });

  useEffect(() => {
    localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
    if (isDarkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }, [isDarkMode]);

  const toggleDarkMode = () => {
    setIsDarkMode(prev => !prev);
  };

  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      console.log("Auth state changed. User:", user);
      setUser(user as CustomUser);
      setLoading(false);
    });
    return unsubscribe;
  }, []);

  const saveUserToDatabase = async (user: User) => {
    // Save to Firestore (for user profiles)
    const userRef = doc(db, 'users', user.uid);
    await setDoc(userRef, {
      uid: user.uid,
      email: user.email,
      displayName: user.displayName,
      photoURL: user.photoURL,
      companyId: 'default',
    }, { merge: true });

    // Save to Realtime Database (if needed for real-time features)
    const rtdbUserRef = ref(database, `users/${user.uid}`);
    await set(rtdbUserRef, {
      online: true,
      lastSeen: new Date().toISOString(),
      // ... other real-time data
    });
  };

  const login = async (email: string, password: string) => {
    const userCredential = await signInWithEmailAndPassword(auth, email, password);
    await saveUserToDatabase(userCredential.user);
    return userCredential;
  };

  const register = async (email: string, password: string) => {
    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
    await saveUserToDatabase(userCredential.user);
    return userCredential;
  };

  const logout = () => {
    return signOut(auth);
  };

  const googleSignIn = async () => {
    const provider = new GoogleAuthProvider();
    const userCredential = await signInWithPopup(auth, provider);
    await saveUserToDatabase(userCredential.user);
    return userCredential;
  };

  const value = {
    user,
    setUser,
    login,
    register,
    logout,
    googleSignIn,
    isDarkMode,
    toggleDarkMode,
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};


--- File: ./src/context/CodebaseContext.tsx ---

import React, { createContext, useContext, useState } from 'react';

interface CodebaseContextType {
  selectedRepository: string | null;
  setSelectedRepository: (repo: string | null) => void;
}

const CodebaseContext = createContext<CodebaseContextType | undefined>(undefined);

export function CodebaseProvider({ children }: { children: React.ReactNode }) {
  const [selectedRepository, setSelectedRepository] = useState<string | null>(null);

  return (
    <CodebaseContext.Provider value={{ selectedRepository, setSelectedRepository }}>
      {children}
    </CodebaseContext.Provider>
  );
}

export function useCodebase() {
  const context = useContext(CodebaseContext);
  if (context === undefined) {
    throw new Error('useCodebase must be used within a CodebaseProvider');
  }
  return context;
}

--- File: ./src/types/react-responsive-modal.d.ts ---

declare module 'react-responsive-modal' {
    import { ReactNode } from 'react';
  
    export interface ModalProps {
      open: boolean;
      onClose: () => void;
      center?: boolean;
      closeOnEsc?: boolean;
      closeOnOverlayClick?: boolean;
      classNames?: {
        overlay?: string;
        modal?: string;
        modalAnimationIn?: string;
        modalAnimationOut?: string;
        overlayAnimationIn?: string;
        overlayAnimationOut?: string;
      };
      children?: ReactNode;
      showCloseIcon?: boolean;
      closeIcon?: ReactNode;
      styles?: {
        overlay?: React.CSSProperties;
        modal?: React.CSSProperties;
        closeButton?: React.CSSProperties;
        closeIcon?: React.CSSProperties;
      };
      animationDuration?: number;
      blockScroll?: boolean;
    }
  
    export class Modal extends React.Component<ModalProps> {}
  }

--- File: ./src/types/ticket.ts ---

import type { BoardStatus, BacklogStatus } from './board';

// Use the union type directly instead of importing TicketStatus
export type TicketStatus = BoardStatus | BacklogStatus;

export type TicketPriority = 'low' | 'medium' | 'high';

export type TicketType = 'bug' | 'task' | 'story';

export interface Ticket {
    id: string;
    ticket_id: string;
    accountId: string;  // Add this field to tie tickets to accounts
    title: string;
    description: string;
    status: TicketStatus;
    priority: TicketPriority;
    assigneeId?: string;
    type: TicketType;
    createdBy: string;
    createdAt: number;
    updatedAt: number;
    order: number;
}


--- File: ./src/types/user.ts ---

import { User as FirebaseUser } from 'firebase/auth';

export interface CustomUser {
  uid: string;
  email: string;
  displayName?: string;
  photoURL?: string;
  accountIds?: string[];
  companyId?: string;
}

--- File: ./src/types/account.ts ---

export interface Account {
    id: string;
    name: string;
    createdAt: string;
    updatedAt: string;
    ownerId: string;
    settings: {
      githubRepository?: string;
      // Other account-wide settings can go here
    };
    members: {
      [userId: string]: {
        role: 'owner' | 'admin' | 'member';
        joinedAt: string;
      };
    };
  }

--- File: ./src/types/repository.ts ---

export interface RepositoryFile {
  path: string;
  content: string;
  sha: string;
  size: number;
  type: 'file' | 'directory';
  lastModified?: Date;
}

export interface Repository {
  files: RepositoryFile[];
  metadata: {
    name: string;
    description?: string;
    default_branch: string;
    sync_status: string;
    last_synced?: Date;
    accountId: string;
  };
}

// Optional: Add repository status types for better type safety
export type RepositorySyncStatus = 
  | 'not_synced'
  | 'syncing'
  | 'synced'
  | 'error';

// Optional: Add repository type for better organization
export type RepositoryType = 
  | 'github'
  | 'gitlab'
  | 'bitbucket';

--- File: ./src/types/message.ts ---

export interface Message {
    id?: string;
    content: string;
    timestamp: number;
    userId: string;
    channelId?: string;
    status?: string;
    participants?: string[];
  }

--- File: ./src/types/board/columns.ts ---

import { Column, BacklogColumnsType, DevelopmentColumnsType } from './index';

export const COLUMN_STATUS_LABELS = {
  // Backlog statuses
  'BACKLOG_ICEBOX': 'Icebox',
  'BACKLOG_NEW': 'New',
  'BACKLOG_REFINED': 'Refined',
  'BACKLOG_DEV_NEXT': 'Next for Development',
  // Development statuses
  'SELECTED_FOR_DEV': 'Selected for Development',
  'IN_PROGRESS': 'In Progress',
  'READY_FOR_TESTING': 'Ready for Testing',
  'DEPLOYED': 'Deployed'
} as const;

export const backlogColumns: BacklogColumnsType = {
  'BACKLOG_ICEBOX': { title: COLUMN_STATUS_LABELS['BACKLOG_ICEBOX'], tickets: [] },
  'BACKLOG_NEW': { title: COLUMN_STATUS_LABELS['BACKLOG_NEW'], tickets: [] },
  'BACKLOG_REFINED': { title: COLUMN_STATUS_LABELS['BACKLOG_REFINED'], tickets: [] },
  'BACKLOG_DEV_NEXT': { title: COLUMN_STATUS_LABELS['BACKLOG_DEV_NEXT'], tickets: [] }
};

export const developmentColumns: DevelopmentColumnsType = {
  'SELECTED_FOR_DEV': { title: COLUMN_STATUS_LABELS['SELECTED_FOR_DEV'], tickets: [] },
  'IN_PROGRESS': { title: COLUMN_STATUS_LABELS['IN_PROGRESS'], tickets: [] },
  'READY_FOR_TESTING': { title: COLUMN_STATUS_LABELS['READY_FOR_TESTING'], tickets: [] },
  'DEPLOYED': { title: COLUMN_STATUS_LABELS['DEPLOYED'], tickets: [] }
};

--- File: ./src/types/board/index.ts ---

import { Ticket } from '../ticket';

// Define status types
export type BoardStatus = 
  | 'SELECTED_FOR_DEV'
  | 'IN_PROGRESS'
  | 'READY_FOR_TESTING'
  | 'DEPLOYED';

export type BacklogStatus = 
  | 'BACKLOG_ICEBOX'
  | 'BACKLOG_NEW'
  | 'BACKLOG_REFINED'
  | 'BACKLOG_DEV_NEXT';

export type TicketStatus = BoardStatus | BacklogStatus;

export interface Column {
  title: string;
  tickets: Ticket[];
}

export type BacklogColumnsType = Record<BacklogStatus, Column>;
export type DevelopmentColumnsType = Record<BoardStatus, Column>;

export * from './columns';

--- File: ./src/styles/index.ts ---

export * from './theme';
export * from './layout';
export * from './animations';


--- File: ./src/styles/theme.ts ---

import { animations } from './animations';

export const theme = {
  colors: {
    // Dark mode colors
    dark: {
      primary: '#1e2132', // Left nav background
      secondary: '#2b2f44', // Hover state
      text: {
        primary: '#f3f4f6', // Light text on dark background
        secondary: '#9ca3af', // Dimmed text
        muted: '#6b7280', // Even more dimmed text
      },
      background: {
        primary: '#262b3d', // Main background
        secondary: '#1e2132', // Secondary background (cards, etc)
        hover: '#313a55', // Hover state
      },
      border: '#374151',
    },
    // Light mode colors
    light: {
      primary: '#ffffff',
      secondary: '#f3f4f6',
      text: {
        primary: '#111827',    // Almost black for primary text
        secondary: '#374151',  // Dark gray for secondary text
        muted: '#6B7280',     // Medium gray for muted text
      },
      background: {
        primary: '#ffffff',
        secondary: '#f9fafb',
        hover: '#f3f4f6',
      },
      border: '#e5e7eb',
    },
    // Shared colors (same in both modes)
    shared: {
      blue: {
        primary: '#1d4ed8',
        hover: '#1e40af',
      },
      status: {
        success: '#059669',
        warning: '#d97706',
        error: '#dc2626',
      },
      priority: {
        high: {
          text: '#dc2626',
          bg: '#fee2e2',
        },
        medium: {
          text: '#d97706',
          bg: '#fef3c7',
        },
        low: {
          text: '#059669',
          bg: '#d1fae5',
        },
      },
    },
  },
  borderRadius: {
    sm: '0.375rem',
    md: '0.5rem',
    lg: '0.75rem',
    xl: '1rem',
  },
  spacing: {
    1: '0.25rem',
    2: '0.5rem',
    3: '0.75rem',
    4: '1rem',
    5: '1.25rem',
    6: '1.5rem',
    8: '2rem',
  },
};

export const commonStyles = {
  layout: {
    sidebar: `
      w-64 h-full flex flex-col
      bg-[#1e2132] dark:bg-[#1e2132]
      border-r border-gray-700
    `,
    main: `
      flex-1 
      bg-[#262b3d] dark:bg-[#262b3d]
    `,
    content: `
      min-h-screen
      bg-white dark:bg-[#262b3d]
      p-6
    `,
  },

  button: {
    base: `
      flex items-center gap-2 px-4 py-2 rounded-lg
      font-medium
      ${animations.transition.normal}
      disabled:opacity-50 disabled:cursor-not-allowed
    `,
    primary: `
      bg-[${theme.colors.dark.background.hover}] hover:bg-[${theme.colors.dark.secondary}]
      text-white
      shadow-sm
    `,
    secondary: `
      bg-[${theme.colors.dark.background.hover}] hover:bg-[${theme.colors.dark.secondary}]
      text-gray-200
    `,
    danger: `
      bg-red-600 
      text-white 
      hover:bg-red-700 
      dark:bg-red-500 
      dark:hover:bg-red-600
      flex items-center
    `,
  },

  navLink: {
    base: `
      flex items-center p-2 rounded-lg
      text-gray-400 hover:text-gray-200 hover:bg-[#313a55]
    `,
    active: `
      bg-[#313a55] text-gray-200
    `,
  },

  ticket: {
    card: `
      bg-white dark:bg-[${theme.colors.dark.background.secondary}]
      border border-gray-200 dark:border-gray-700
      rounded-lg p-4 mb-4
      hover:bg-gray-50 dark:hover:bg-[${theme.colors.dark.background.hover}]
      ${animations.transition.normal}
    `,
    priority: {
      low: 'text-green-400',
      medium: 'text-yellow-400',
      high: 'text-red-400',
    },
    title: `
      text-gray-900 dark:text-gray-200
      font-medium text-base
    `,
    description: `
      text-gray-700 dark:text-gray-300
      text-sm mt-1
    `,
    metadata: `
      text-gray-600 dark:text-gray-400
      text-sm
    `,
  },

  card: `
    bg-white dark:bg-gray-800
    border border-gray-200 dark:border-gray-700
    rounded-lg shadow-sm
  `,
  input: `
    w-full px-4 py-2 rounded-lg
    bg-white dark:bg-gray-700
    border border-gray-200 dark:border-gray-600
    text-gray-900 dark:text-gray-100
    placeholder-gray-500 dark:placeholder-gray-400
    focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400
    focus:border-transparent
    ${animations.transition.normal}
  `,
  modal: `
    bg-white dark:bg-[#1e2132]
    border border-gray-200 dark:border-gray-700
    rounded-xl shadow-lg
  `,
  sidebar: {
    nav: {
      item: `
        flex items-center px-4 py-2 rounded-xl
        transition-colors duration-200
        font-medium
      `,
      active: `
        bg-[#2b2f44] text-gray-100
      `,
      inactive: `
        text-gray-400 hover:text-gray-100 hover:bg-[#2b2f44]
      `,
    },
  },
  header: {
    wrapper: `
      sticky top-0 z-10
      bg-gray-100 dark:bg-[${theme.colors.dark.background.primary}]
      border-b border-gray-200 dark:border-gray-700
    `,
    container: `
      flex items-center justify-between
      px-6 py-4
    `,
    titleWrapper: `
      flex flex-col
    `,
    title: `
      text-lg font-semibold
      text-gray-900 dark:text-gray-200
    `,
    subtitle: `
      text-sm
      text-gray-600 dark:text-gray-400
    `,
    actions: `
      flex items-center gap-3
    `,
  },
};

export const typography = {
  brand: 'text-xl font-semibold text-gray-200',
  sidebarHeader: 'text-lg font-semibold text-gray-200',
  sectionHeader: 'text-sm font-medium text-gray-900 dark:text-gray-200 mb-4',
  h1: 'text-xl font-semibold text-gray-900 dark:text-gray-200',
  h2: 'text-lg font-semibold text-gray-900 dark:text-gray-200',
  h3: 'text-base font-semibold text-gray-900 dark:text-gray-200',
  h4: 'text-sm font-semibold text-gray-900 dark:text-gray-200',
  body: 'text-gray-700 dark:text-gray-300',
  small: 'text-sm text-gray-600 dark:text-gray-400',
  subtitle: 'text-gray-600 dark:text-gray-400 text-sm',
};


--- File: ./src/styles/typography.ts ---

export const typography = {
  h1: 'text-4xl font-bold text-gray-900 dark:text-gray-100',
  h2: 'text-3xl font-bold text-gray-900 dark:text-gray-100',
  h3: 'text-2xl font-bold text-gray-900 dark:text-gray-100',
  h4: 'text-xl font-bold text-gray-900 dark:text-gray-100',
  body: 'text-base text-gray-700 dark:text-gray-300',
  small: 'text-sm text-gray-600 dark:text-gray-400',
  link: 'text-blue-600 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300',
};


--- File: ./src/styles/layout.ts ---

export const layout = {
  container: {
    default: 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8',
    fluid: 'w-full px-4 sm:px-6 lg:px-8',
    narrow: 'max-w-5xl mx-auto px-4 sm:px-6 lg:px-8',
  },
  section: 'py-6 sm:py-8 lg:py-12',
  grid: {
    cols2: 'grid grid-cols-1 md:grid-cols-2 gap-6',
    cols3: 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6',
    cols4: 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6',
  },
  flex: {
    center: 'flex items-center justify-center',
    between: 'flex items-center justify-between',
    start: 'flex items-start justify-start',
    end: 'flex items-center justify-end',
  },
};


--- File: ./src/styles/animations.ts ---

export const animations = {
  transition: {
    normal: 'transition-all duration-200 ease-in-out',
    fast: 'transition-all duration-150 ease-in-out',
    slow: 'transition-all duration-300 ease-in-out',
  },
  hover: {
    scale: 'hover:scale-105',
    lift: 'hover:-translate-y-1',
    glow: 'hover:shadow-lg',
  },
  fade: {
    enter: 'animate-fade-in',
    exit: 'animate-fade-out',
  },
};


--- File: ./src/routes/settings.tsx ---

import { RouteObject } from 'react-router-dom';
import { SettingsLayout, GitHubSettings, UserManagement } from '../components/Settings';

export const settingsRoutes: RouteObject[] = [
  {
    path: '/settings',
    element: <SettingsLayout />,
    children: [
      {
        index: true,
        element: <GitHubSettings />
      },
      {
        path: 'github',
        element: <GitHubSettings />
      },
      {
        path: 'users',
        element: <UserManagement />
      }
    ]
  }
];

export default settingsRoutes;


--- File: ./src/pages/RegisterPage.tsx ---

import React from 'react';
import Register from '../components/Auth/Register';

const RegisterPage: React.FC = () => {
  return <Register />;
};

export default RegisterPage;


--- File: ./src/pages/LoginPage.tsx ---

import React from 'react';
import { useNavigate } from 'react-router-dom';
import Login from '../components/Auth/Login';

const LoginPage: React.FC = () => {
  const navigate = useNavigate();

  const onLoginSuccess = () => {
    navigate('/');
  };

  return <Login onSuccess={onLoginSuccess} />;
};

export default LoginPage;


--- File: ./src/pages/InvitationPage.tsx ---

import { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { getFunctions, httpsCallable } from 'firebase/functions';
import { useAuth } from '../context/AuthContext';

export default function InvitationPage() {
  const { invitationId } = useParams();
  const { user } = useAuth();
  const navigate = useNavigate();
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleAcceptInvitation = async () => {
    if (!user || !invitationId) return;

    setIsProcessing(true);
    setError(null);

    try {
      const functions = getFunctions();
      const acceptInvitation = httpsCallable(functions, 'handleInvitationAcceptance');
      await acceptInvitation({ invitationId });
      
      // Redirect to dashboard
      navigate('/dashboard');
    } catch (err) {
      console.error('Error accepting invitation:', err);
      setError('Failed to accept invitation. Please try again.');
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow">
        <div className="text-center">
          <h2 className="text-3xl font-bold">Accept Invitation</h2>
          <p className="mt-2 text-gray-600">
            Click below to join the account
          </p>
        </div>

        {error && (
          <div className="bg-red-50 text-red-500 p-4 rounded-md">
            {error}
          </div>
        )}

        <button
          onClick={handleAcceptInvitation}
          disabled={isProcessing}
          className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
        >
          {isProcessing ? 'Processing...' : 'Accept Invitation'}
        </button>
      </div>
    </div>
  );
}

--- File: ./src/migrations/index.ts ---

import { migrateTicketsAddAccountId } from './tickets/add-account-id';

export type MigrationResult = {
  success: boolean;
  migratedCount?: number;
  error?: string;
  message: string;
}

export const migrations = {
  tickets: {
    addAccountId: migrateTicketsAddAccountId
  }
} as const;

export async function runMigration(
  migrationName: keyof typeof migrations.tickets
): Promise<MigrationResult> {
  console.log(`Running migration: ${migrationName}`);
  
  try {
    switch (migrationName) {
      case 'addAccountId':
        return await migrations.tickets.addAccountId();
      default:
        throw new Error(`Unknown migration: ${migrationName}`);
    }
  } catch (error) {
    console.error(`Migration failed: ${migrationName}`, error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      message: `Migration failed: ${migrationName}`
    };
  }
}


--- File: ./src/migrations/tickets/add-account-id.ts ---

import { collection, getDocs, updateDoc, doc, writeBatch } from 'firebase/firestore';
import { db } from '../../config/firebase';

const DEFAULT_ACCOUNT_ID = 'RnInDl1twWVwyWWMcEkB1sETtoq1';
const BATCH_SIZE = 500;

export async function migrateTicketsAddAccountId() {
  try {
    console.log('Starting ticket migration...');
    const ticketsRef = collection(db, 'tickets');
    const snapshot = await getDocs(ticketsRef);
    
    let migratedCount = 0;
    let currentBatch = writeBatch(db);
    let operationsInBatch = 0;

    for (const ticketDoc of snapshot.docs) {
      const ticket = ticketDoc.data();
      
      if (!ticket.accountId) {
        currentBatch.update(doc(db, 'tickets', ticketDoc.id), {
          accountId: DEFAULT_ACCOUNT_ID,
          updatedAt: Date.now()
        });
        
        operationsInBatch++;
        migratedCount++;

        if (operationsInBatch === BATCH_SIZE) {
          await currentBatch.commit();
          currentBatch = writeBatch(db);
          operationsInBatch = 0;
          console.log(`Committed batch of ${BATCH_SIZE} operations`);
        }
      }
    }

    if (operationsInBatch > 0) {
      await currentBatch.commit();
      console.log(`Committed final batch of ${operationsInBatch} operations`);
    }

    console.log(`Successfully migrated ${migratedCount} tickets`);
    return {
      success: true,
      migratedCount,
      message: `Successfully migrated ${migratedCount} tickets`
    };
  } catch (error) {
    console.error('Error migrating tickets:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      message: 'Failed to migrate tickets'
    };
  }
}

export async function verifyTicketMigration() {
  try {
    console.log('[Migration] Starting ticket verification...');
    const ticketsRef = collection(db, 'tickets');
    const snapshot = await getDocs(ticketsRef);
    
    const ticketsByAccount: Record<string, number> = {};
    const ticketsWithoutAccount: string[] = [];
    
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      if (data.accountId) {
        ticketsByAccount[data.accountId] = (ticketsByAccount[data.accountId] || 0) + 1;
      } else {
        ticketsWithoutAccount.push(doc.id);
      }
    });
    
    console.log('[Migration] Verification results:', {
      total: snapshot.docs.length,
      byAccount: ticketsByAccount,
      withoutAccount: ticketsWithoutAccount
    });
    
    return {
      success: ticketsWithoutAccount.length === 0,
      ticketsByAccount,
      ticketsWithoutAccount
    };
  } catch (error) {
    console.error('[Migration] Verification error:', error);
    throw error;
  }
}

--- File: ./src/config/firebase.ts ---

import { initializeApp, getApps, deleteApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';
import { getFunctions } from 'firebase/functions';
import { getDatabase } from 'firebase/database';

// Clear any existing Firebase apps
const apps = getApps();
for (const app of apps) {
  deleteApp(app);
}

const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_FIREBASE_APP_ID,
  databaseURL: process.env.REACT_APP_FIREBASE_DATABASE_URL,
  measurementId: process.env.REACT_APP_FIREBASE_MEASUREMENT_ID
};

// Initialize Firebase
export const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const db = getFirestore(app);
export const functions = getFunctions(app);
export const database = getDatabase(app);

--- File: ./repository-indexer/src/services/api.ts ---

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001';

export const syncRepository = async (repositoryName: string, userId: string) => {
  const response = await fetch(`${API_BASE_URL}/api/repository/sync`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ repositoryName, userId }),
  });

  if (!response.ok) {
    throw new Error('Failed to start repository sync');
  }

  return response.json();
};


--- File: ./repository-indexer/venv/lib/python3.12/site-packages/urllib3/contrib/emscripten/emscripten_fetch_worker.js ---

let Status = {
  SUCCESS_HEADER: -1,
  SUCCESS_EOF: -2,
  ERROR_TIMEOUT: -3,
  ERROR_EXCEPTION: -4,
};

let connections = {};
let nextConnectionID = 1;
const encoder = new TextEncoder();

self.addEventListener("message", async function (event) {
  if (event.data.close) {
    let connectionID = event.data.close;
    delete connections[connectionID];
    return;
  } else if (event.data.getMore) {
    let connectionID = event.data.getMore;
    let { curOffset, value, reader, intBuffer, byteBuffer } =
      connections[connectionID];
    // if we still have some in buffer, then just send it back straight away
    if (!value || curOffset >= value.length) {
      // read another buffer if required
      try {
        let readResponse = await reader.read();

        if (readResponse.done) {
          // read everything - clear connection and return
          delete connections[connectionID];
          Atomics.store(intBuffer, 0, Status.SUCCESS_EOF);
          Atomics.notify(intBuffer, 0);
          // finished reading successfully
          // return from event handler
          return;
        }
        curOffset = 0;
        connections[connectionID].value = readResponse.value;
        value = readResponse.value;
      } catch (error) {
        console.log("Request exception:", error);
        let errorBytes = encoder.encode(error.message);
        let written = errorBytes.length;
        byteBuffer.set(errorBytes);
        intBuffer[1] = written;
        Atomics.store(intBuffer, 0, Status.ERROR_EXCEPTION);
        Atomics.notify(intBuffer, 0);
      }
    }

    // send as much buffer as we can
    let curLen = value.length - curOffset;
    if (curLen > byteBuffer.length) {
      curLen = byteBuffer.length;
    }
    byteBuffer.set(value.subarray(curOffset, curOffset + curLen), 0);

    Atomics.store(intBuffer, 0, curLen); // store current length in bytes
    Atomics.notify(intBuffer, 0);
    curOffset += curLen;
    connections[connectionID].curOffset = curOffset;

    return;
  } else {
    // start fetch
    let connectionID = nextConnectionID;
    nextConnectionID += 1;
    const intBuffer = new Int32Array(event.data.buffer);
    const byteBuffer = new Uint8Array(event.data.buffer, 8);
    try {
      const response = await fetch(event.data.url, event.data.fetchParams);
      // return the headers first via textencoder
      var headers = [];
      for (const pair of response.headers.entries()) {
        headers.push([pair[0], pair[1]]);
      }
      let headerObj = {
        headers: headers,
        status: response.status,
        connectionID,
      };
      const headerText = JSON.stringify(headerObj);
      let headerBytes = encoder.encode(headerText);
      let written = headerBytes.length;
      byteBuffer.set(headerBytes);
      intBuffer[1] = written;
      // make a connection
      connections[connectionID] = {
        reader: response.body.getReader(),
        intBuffer: intBuffer,
        byteBuffer: byteBuffer,
        value: undefined,
        curOffset: 0,
      };
      // set header ready
      Atomics.store(intBuffer, 0, Status.SUCCESS_HEADER);
      Atomics.notify(intBuffer, 0);
      // all fetching after this goes through a new postmessage call with getMore
      // this allows for parallel requests
    } catch (error) {
      console.log("Request exception:", error);
      let errorBytes = encoder.encode(error.message);
      let written = errorBytes.length;
      byteBuffer.set(errorBytes);
      intBuffer[1] = written;
      Atomics.store(intBuffer, 0, Status.ERROR_EXCEPTION);
      Atomics.notify(intBuffer, 0);
    }
  }
});
self.postMessage({ inited: true });


--- File: ./functions/.eslintrc.js ---

module.exports = {
  root: true,
  env: {
    es6: true,
    node: true,
  },
  extends: [
    "eslint:recommended",
    "plugin:import/errors",
    "plugin:import/warnings",
    "plugin:import/typescript",
    "plugin:@typescript-eslint/recommended",
    "plugin:prettier/recommended",
  ],
  parser: "@typescript-eslint/parser",
  parserOptions: {
    project: ["tsconfig.json"],
    sourceType: "module",
  },
  ignorePatterns: [
    "/lib/**/*", // Ignore built files.
  ],
  plugins: [
    "@typescript-eslint",
    "import",
    "prettier"
  ],
  rules: {
    "prettier/prettier": "error",
    "import/no-unresolved": 0,
    "@typescript-eslint/no-explicit-any": "warn",
  },
};


--- File: ./functions/index.js ---

/**
 * Import function triggers from their respective submodules:
 *
 * const {onCall} = require("firebase-functions/v2/https");
 * const {onDocumentWritten} = require("firebase-functions/v2/firestore");
 *
 * See a full list of supported triggers at https://firebase.google.com/docs/functions
 */

const functions = require("firebase-functions");
const admin = require("firebase-admin");

admin.initializeApp();

// Create and deploy your first functions
// https://firebase.google.com/docs/functions/get-started

exports.api = functions.https.onRequest((request, response) => {
  return cors(request, response, function() {
    console.log('Function invoked with method:', request.method);
    console.log('Request headers:', request.headers);
    console.log('Request body:', request.body);

    if (request.method === 'OPTIONS') {
      // Send response to OPTIONS requests
      response.set('Access-Control-Allow-Methods', 'GET, POST');
      response.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
      response.set('Access-Control-Max-Age', '3600');
      response.status(204).send('');
      return;
    }

    if (request.method !== 'POST') {
      return response.status(405).send('Method Not Allowed');
    }

    // Verify Firebase ID token
    if (!request.headers.authorization ||
        !request.headers.authorization.startsWith('Bearer ')) {
      console.error('No Authorization header or incorrect format');
      return response.status(403).send('Unauthorized');
    }
    const idToken = request.headers.authorization.split('Bearer ')[1];
    admin.auth().verifyIdToken(idToken)
      .then((decodedToken) => {
        console.log('Token verified for user:', decodedToken.uid);

        const { companyId } = request.body;

        if (!companyId) {
          return response.status(400).send('Company ID is required');
        }

        return admin.database().ref('users')
          .orderByChild('companyId')
          .equalTo(companyId)
          .once('value');
      })
      .then((usersSnapshot) => {
        const users = usersSnapshot.val();
        console.log('Users fetched:', users);
        return response.status(200).json(users || {});
      })
      .catch((error) => {
        console.error('Error:', error);
        return response.status(401).send('Unauthorized: ' + error.message);
      });
  });
});

// Function to add a user
exports.addUser = functions.https.onCall(async (data, context) => {
  console.log("addUser function called");
  console.log("Received data:", JSON.stringify(data));

  try {
    // Check if user is authenticated
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated to add a user.');
    }

    const { name, email, companyId } = data;

    if (!name || !email || !companyId) {
      throw new functions.https.HttpsError('invalid-argument', 'Name, email, and companyId are required.');
    }

    const userRef = admin.database().ref('users').push();
    await userRef.set({
      name,
      email,
      companyId
    });

    return { success: true, message: 'User added successfully', userId: userRef.key };
  } catch (error) {
    console.error('Error adding user:', error);
    throw new functions.https.HttpsError('internal', 'Error adding user: ' + error.message);
  }
});

// Function to retrieve users by company ID
exports.getUsers = functions.https.onCall(async (data, context) => {
  // Check if user is authenticated
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated to retrieve users.');
  }

  const { companyId } = data;

  if (!companyId) {
    throw new functions.https.HttpsError('invalid-argument', 'Company ID is required.');
  }

  try {
    const usersSnapshot = await admin.database().ref('users')
      .orderByChild('companyId')
      .equalTo(companyId)
      .once('value');

    const users = usersSnapshot.val();
    return users || {};
  } catch (error) {
    console.error('Error retrieving users:', error);
    throw new functions.https.HttpsError('internal', 'Error retrieving users: ' + error.message);
  }
});

// Function to get all users
exports.getAllUsers = functions.https.onCall(async (data, context) => {
  console.log("getAllUsers function called");

  try {
    // For testing in emulator, we'll pass an empty object if no data is provided
    const requestData = data || {};
    console.log("Request data:", JSON.stringify(requestData));

    // Skip auth check in emulator
    if (!process.env.FUNCTIONS_EMULATOR && !context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated to retrieve users.');
    }

    console.log("Fetching all users from database");
    const usersSnapshot = await admin.database().ref('users').once('value');
    const users = usersSnapshot.val();
    
    console.log("Users fetched:", JSON.stringify(users, null, 2));
    return users || {};
  } catch (error) {
    console.error('Error retrieving users:', error);
    throw new functions.https.HttpsError('internal', 'Error retrieving users: ' + error.message);
  }
});


--- File: ./functions/lib/index.js ---

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncGithubRepository = exports.storeGithubToken = exports.sendInvitation = void 0;
const https_1 = require("firebase-functions/v2/https");
const admin = __importStar(require("firebase-admin"));
const rest_1 = require("@octokit/rest");
// Initialize Firebase Admin
try {
    admin.initializeApp();
}
catch (error) {
    console.error('Firebase Admin initialization error:', error);
}
// TODO: Implement these user management functions later
// export const addUser = ...
// export const getUsers = ...
// export const getAllUsers = ...
// export const api = ...
exports.sendInvitation = (0, https_1.onCall)({
    cors: true
}, async (request) => {
    console.log('Function triggered');
    try {
        const { email, accountName, role, invitationId } = request.data;
        console.log('Received data:', { email, accountName, role, invitationId });
        // Just return success without doing anything
        return {
            success: true,
            message: 'Function called successfully',
            receivedData: { email, accountName, role, invitationId }
        };
    }
    catch (error) {
        console.error('Function error:', error);
        throw new Error('Function error: ' + (error instanceof Error ? error.message : 'Unknown error'));
    }
});
// Store GitHub token securely
exports.storeGithubToken = (0, https_1.onCall)({
    cors: true
}, async (request) => {
    // Add logging to see what we're receiving
    console.log('Received request data:', request.data);
    if (!request.data || !request.data.token || !request.data.accountId) {
        throw new Error('Missing required fields: token and accountId');
    }
    const { token, accountId } = request.data;
    try {
        // Verify token is valid
        const octokit = new rest_1.Octokit({ auth: token });
        await octokit.users.getAuthenticated();
        // Store token
        await admin.firestore()
            .collection('secure_tokens')
            .doc(accountId)
            .set({
            githubToken: token,
            updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        return { success: true };
    }
    catch (error) {
        console.error('Error storing GitHub token:', error);
        throw new Error('Invalid GitHub token or storage error');
    }
});
// Function to sync repository
exports.syncGithubRepository = (0, https_1.onCall)({
    cors: true,
    timeoutSeconds: 540 // 9 minutes timeout for large repos
}, async (request) => {
    if (!request.auth) {
        throw new Error('Unauthenticated');
    }
    const { repositoryName, accountId } = request.data;
    try {
        // Get token from secure storage
        const tokenDoc = await admin.firestore()
            .collection('secure_tokens')
            .doc(accountId)
            .get();
        if (!tokenDoc.exists) {
            throw new Error('GitHub token not found');
        }
        const { githubToken } = tokenDoc.data();
        const octokit = new rest_1.Octokit({ auth: githubToken });
        // Start repository sync
        const [owner, repo] = repositoryName.split('/');
        // Update sync status
        const repoRef = admin.firestore()
            .collection('repositories')
            .doc(repositoryName.replace('/', '_'));
        await repoRef.set({
            metadata: {
                sync_status: 'syncing',
                last_synced: admin.firestore.FieldValue.serverTimestamp(),
                error: null
            }
        }, { merge: true });
        // Get repository contents
        const { data: contents } = await octokit.repos.getContent({
            owner,
            repo,
            path: ''
        });
        // Process repository contents
        const files = Array.isArray(contents) ? contents : [contents];
        const processedFiles = await processFiles(files, octokit, owner, repo);
        // Store files in Firestore
        await repoRef.set({
            files: processedFiles,
            metadata: {
                sync_status: 'completed',
                last_synced: admin.firestore.FieldValue.serverTimestamp(),
                error: null
            }
        }, { merge: true });
        return { success: true };
    }
    catch (error) {
        console.error('Sync error:', error);
        // Update status with error
        await admin.firestore()
            .collection('repositories')
            .doc(repositoryName.replace('/', '_'))
            .set({
            metadata: {
                sync_status: 'failed',
                error: error instanceof Error ? error.message : 'Unknown error',
                last_synced: admin.firestore.FieldValue.serverTimestamp()
            }
        }, { merge: true });
        throw new Error('Failed to sync repository');
    }
});
// Helper function to process files recursively with proper typing
async function processFiles(files, octokit, owner, repo, path = '') {
    const processedFiles = [];
    for (const file of files) {
        if (file.type === 'file') {
            const { data: content } = await octokit.repos.getContent({
                owner,
                repo,
                path: file.path,
                mediaType: {
                    format: 'raw'
                }
            });
            processedFiles.push({
                path: file.path,
                type: 'file',
                size: file.size,
                content: typeof content === 'string' ? content : null,
                indexed_at: admin.firestore.Timestamp.now()
            });
        }
        else if (file.type === 'dir') {
            const { data: dirContents } = await octokit.repos.getContent({
                owner,
                repo,
                path: file.path
            });
            const subFiles = await processFiles(Array.isArray(dirContents) ? dirContents : [dirContents], octokit, owner, repo, file.path);
            processedFiles.push(...subFiles);
        }
    }
    return processedFiles;
}
//# sourceMappingURL=index.js.map

--- File: ./functions/src/index.ts ---

import { onCall } from 'firebase-functions/v2/https';
import * as admin from 'firebase-admin';

// Initialize Firebase Admin
try {
  admin.initializeApp();
} catch (error) {
  console.error('Firebase Admin initialization error:', error);
}

interface InvitationData {
  email: string;
  accountName: string;
  role: 'admin' | 'member';
  invitationId: string;
}

interface InvitationAcceptanceData {
  invitationId: string;
}

export const sendInvitation = onCall(
  { 
    cors: true
  }, 
  async (request) => {
    console.log('Function triggered');
    
    try {
      const { email, accountName, role, invitationId } = request.data;
      console.log('Received data:', { email, accountName, role, invitationId });

      // Just return success without doing anything
      return { 
        success: true,
        message: 'Function called successfully',
        receivedData: { email, accountName, role, invitationId }
      };
    } catch (error) {
      console.error('Function error:', error);
      throw new Error('Function error: ' + (error instanceof Error ? error.message : 'Unknown error'));
    }
  }
);

export const handleInvitationAcceptance = onCall<InvitationAcceptanceData>({
    maxInstances: 10,
    cors: ['http://localhost:3000']
  },
  async (request) => {
    if (!request.auth) {
      throw new Error('Unauthenticated');
    }

    const { invitationId } = request.data;
    const userId = request.auth.uid;

    try {
      const invitationRef = admin.firestore().collection('invitations').doc(invitationId);
      const invitation = await invitationRef.get();

      if (!invitation.exists) {
        throw new Error('Invitation not found');
      }

      const invitationData = invitation.data()!;

      if (invitationData.status !== 'pending') {
        throw new Error('Invitation has already been used');
      }

      if (new Date(invitationData.expiresAt.toDate()) < new Date()) {
        throw new Error('Invitation has expired');
      }

      // Add user to account
      const accountRef = admin.firestore().collection('accounts').doc(invitationData.accountId);
      await accountRef.update({
        [`members.${userId}`]: {
          role: invitationData.role,
          joinedAt: admin.firestore.FieldValue.serverTimestamp(),
        },
      });

      // Update user's account reference
      await admin.firestore().collection('users').doc(userId).update({
        accountId: invitationData.accountId,
      });

      // Mark invitation as accepted
      await invitationRef.update({
        status: 'accepted',
        acceptedBy: userId,
        acceptedAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      return { success: true };
    } catch (error) {
      console.error('Error accepting invitation:', error);
      throw new Error('Failed to process invitation');
    }
  }
);

--- File: ./backend/src/index.ts ---

import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import repositoryRoutes from './routes/repository';
import { onCall } from 'firebase-functions/v2/https';
import * as admin from 'firebase-admin';
import * as nodemailer from 'nodemailer';

dotenv.config();

const app = express();
const port = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json());

// Routes
app.use('/api/repository', repositoryRoutes);

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

admin.initializeApp();

interface InvitationData {
  email: string;
  accountName: string;
  role: 'admin' | 'member';
  invitationId: string;
}

export const sendInvitation = onCall<InvitationData>({
    maxInstances: 10,
    cors: ['http://localhost:3000']
  }, 
  async (request) => {
    if (!request.auth) {
      throw new Error('Unauthenticated');
    }

    const { email, accountName, role, invitationId } = request.data;

    try {
      // For testing, log the request
      console.log('Received invitation request:', {
        email,
        accountName,
        role,
        invitationId
      });

      // Create invitation document
      const invitationRef = admin.firestore().collection('invitations').doc(invitationId);
      await invitationRef.set({
        email,
        accountName,
        role,
        status: 'pending',
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        expiresAt: admin.firestore.Timestamp.fromDate(
          new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
        ),
      });

      // For development, just log instead of sending email
      console.log('Would send email to:', email);
      
      return { 
        success: true,
        message: 'Invitation created successfully'
      };
    } catch (error) {
      console.error('Error processing invitation:', error);
      throw new Error('Failed to process invitation');
    }
  }
);

app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});


--- File: ./backend/src/routes/repository.ts ---

import express from 'express';
import { spawn } from 'child_process';
import path from 'path';

const router = express.Router();

router.post('/sync', async (req, res) => {
  try {
    const { repositoryName, userId } = req.body;
    console.log('Received sync request:', { repositoryName, userId });

    // Get absolute path to Python script
    const scriptPath = path.resolve(__dirname, '../../../repository-indexer/src/main.py');
    const venvPython = path.resolve(__dirname, '../../../repository-indexer/venv/bin/python3');

    console.log(`Starting sync for repository: ${repositoryName}`);
    
    // Use spawn instead of exec to get real-time output
    const pythonProcess = spawn(venvPython, [
      scriptPath,
      repositoryName,
      userId
    ]);

    // Handle real-time output
    pythonProcess.stdout.on('data', (data) => {
      console.log('Python output:', data.toString());
    });

    pythonProcess.stderr.on('data', (data) => {
      console.error('Python error:', data.toString());
    });

    // Handle process completion
    pythonProcess.on('close', (code) => {
      console.log(`Python process exited with code ${code}`);
    });

    // Send immediate response
    return res.status(200).json({ 
      message: 'Sync started successfully',
      status: 'syncing'
    });

  } catch (error) {
    console.error('Route error:', error);
    return res.status(500).json({ 
      message: 'Internal server error',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

export default router;
